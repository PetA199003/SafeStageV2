
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Canton
 * 
 */
export type Canton = $Result.DefaultSelection<Prisma.$CantonPayload>
/**
 * Model RegulationCategory
 * 
 */
export type RegulationCategory = $Result.DefaultSelection<Prisma.$RegulationCategoryPayload>
/**
 * Model Regulation
 * 
 */
export type Regulation = $Result.DefaultSelection<Prisma.$RegulationPayload>
/**
 * Model CalculationType
 * 
 */
export type CalculationType = $Result.DefaultSelection<Prisma.$CalculationTypePayload>
/**
 * Model CalculationParameter
 * 
 */
export type CalculationParameter = $Result.DefaultSelection<Prisma.$CalculationParameterPayload>
/**
 * Model ExampleCategory
 * 
 */
export type ExampleCategory = $Result.DefaultSelection<Prisma.$ExampleCategoryPayload>
/**
 * Model Example
 * 
 */
export type Example = $Result.DefaultSelection<Prisma.$ExamplePayload>
/**
 * Model ContactType
 * 
 */
export type ContactType = $Result.DefaultSelection<Prisma.$ContactTypePayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model DataVersion
 * 
 */
export type DataVersion = $Result.DefaultSelection<Prisma.$DataVersionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CantonLanguage: {
  DE: 'DE',
  FR: 'FR',
  IT: 'IT',
  RM: 'RM'
};

export type CantonLanguage = (typeof CantonLanguage)[keyof typeof CantonLanguage]


export const ValueType: {
  INT: 'INT',
  FLOAT: 'FLOAT',
  BOOLEAN: 'BOOLEAN',
  STRING: 'STRING'
};

export type ValueType = (typeof ValueType)[keyof typeof ValueType]

}

export type CantonLanguage = $Enums.CantonLanguage

export const CantonLanguage: typeof $Enums.CantonLanguage

export type ValueType = $Enums.ValueType

export const ValueType: typeof $Enums.ValueType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Cantons
 * const cantons = await prisma.canton.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Cantons
   * const cantons = await prisma.canton.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.canton`: Exposes CRUD operations for the **Canton** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cantons
    * const cantons = await prisma.canton.findMany()
    * ```
    */
  get canton(): Prisma.CantonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regulationCategory`: Exposes CRUD operations for the **RegulationCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegulationCategories
    * const regulationCategories = await prisma.regulationCategory.findMany()
    * ```
    */
  get regulationCategory(): Prisma.RegulationCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regulation`: Exposes CRUD operations for the **Regulation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regulations
    * const regulations = await prisma.regulation.findMany()
    * ```
    */
  get regulation(): Prisma.RegulationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calculationType`: Exposes CRUD operations for the **CalculationType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalculationTypes
    * const calculationTypes = await prisma.calculationType.findMany()
    * ```
    */
  get calculationType(): Prisma.CalculationTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calculationParameter`: Exposes CRUD operations for the **CalculationParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalculationParameters
    * const calculationParameters = await prisma.calculationParameter.findMany()
    * ```
    */
  get calculationParameter(): Prisma.CalculationParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exampleCategory`: Exposes CRUD operations for the **ExampleCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExampleCategories
    * const exampleCategories = await prisma.exampleCategory.findMany()
    * ```
    */
  get exampleCategory(): Prisma.ExampleCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.example`: Exposes CRUD operations for the **Example** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Examples
    * const examples = await prisma.example.findMany()
    * ```
    */
  get example(): Prisma.ExampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactType`: Exposes CRUD operations for the **ContactType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactTypes
    * const contactTypes = await prisma.contactType.findMany()
    * ```
    */
  get contactType(): Prisma.ContactTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataVersion`: Exposes CRUD operations for the **DataVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataVersions
    * const dataVersions = await prisma.dataVersion.findMany()
    * ```
    */
  get dataVersion(): Prisma.DataVersionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Canton: 'Canton',
    RegulationCategory: 'RegulationCategory',
    Regulation: 'Regulation',
    CalculationType: 'CalculationType',
    CalculationParameter: 'CalculationParameter',
    ExampleCategory: 'ExampleCategory',
    Example: 'Example',
    ContactType: 'ContactType',
    Contact: 'Contact',
    DataVersion: 'DataVersion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "canton" | "regulationCategory" | "regulation" | "calculationType" | "calculationParameter" | "exampleCategory" | "example" | "contactType" | "contact" | "dataVersion"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Canton: {
        payload: Prisma.$CantonPayload<ExtArgs>
        fields: Prisma.CantonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CantonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CantonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CantonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          findFirst: {
            args: Prisma.CantonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CantonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CantonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          findMany: {
            args: Prisma.CantonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>[]
          }
          create: {
            args: Prisma.CantonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          createMany: {
            args: Prisma.CantonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CantonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          update: {
            args: Prisma.CantonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          deleteMany: {
            args: Prisma.CantonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CantonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CantonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CantonPayload>
          }
          aggregate: {
            args: Prisma.CantonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanton>
          }
          groupBy: {
            args: Prisma.CantonGroupByArgs<ExtArgs>
            result: $Utils.Optional<CantonGroupByOutputType>[]
          }
          count: {
            args: Prisma.CantonCountArgs<ExtArgs>
            result: $Utils.Optional<CantonCountAggregateOutputType> | number
          }
        }
      }
      RegulationCategory: {
        payload: Prisma.$RegulationCategoryPayload<ExtArgs>
        fields: Prisma.RegulationCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegulationCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegulationCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationCategoryPayload>
          }
          findFirst: {
            args: Prisma.RegulationCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegulationCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationCategoryPayload>
          }
          findMany: {
            args: Prisma.RegulationCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationCategoryPayload>[]
          }
          create: {
            args: Prisma.RegulationCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationCategoryPayload>
          }
          createMany: {
            args: Prisma.RegulationCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RegulationCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationCategoryPayload>
          }
          update: {
            args: Prisma.RegulationCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationCategoryPayload>
          }
          deleteMany: {
            args: Prisma.RegulationCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegulationCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegulationCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationCategoryPayload>
          }
          aggregate: {
            args: Prisma.RegulationCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegulationCategory>
          }
          groupBy: {
            args: Prisma.RegulationCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegulationCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegulationCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<RegulationCategoryCountAggregateOutputType> | number
          }
        }
      }
      Regulation: {
        payload: Prisma.$RegulationPayload<ExtArgs>
        fields: Prisma.RegulationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegulationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegulationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationPayload>
          }
          findFirst: {
            args: Prisma.RegulationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegulationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationPayload>
          }
          findMany: {
            args: Prisma.RegulationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationPayload>[]
          }
          create: {
            args: Prisma.RegulationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationPayload>
          }
          createMany: {
            args: Prisma.RegulationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RegulationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationPayload>
          }
          update: {
            args: Prisma.RegulationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationPayload>
          }
          deleteMany: {
            args: Prisma.RegulationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegulationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegulationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegulationPayload>
          }
          aggregate: {
            args: Prisma.RegulationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegulation>
          }
          groupBy: {
            args: Prisma.RegulationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegulationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegulationCountArgs<ExtArgs>
            result: $Utils.Optional<RegulationCountAggregateOutputType> | number
          }
        }
      }
      CalculationType: {
        payload: Prisma.$CalculationTypePayload<ExtArgs>
        fields: Prisma.CalculationTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalculationTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalculationTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationTypePayload>
          }
          findFirst: {
            args: Prisma.CalculationTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalculationTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationTypePayload>
          }
          findMany: {
            args: Prisma.CalculationTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationTypePayload>[]
          }
          create: {
            args: Prisma.CalculationTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationTypePayload>
          }
          createMany: {
            args: Prisma.CalculationTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CalculationTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationTypePayload>
          }
          update: {
            args: Prisma.CalculationTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationTypePayload>
          }
          deleteMany: {
            args: Prisma.CalculationTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalculationTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalculationTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationTypePayload>
          }
          aggregate: {
            args: Prisma.CalculationTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalculationType>
          }
          groupBy: {
            args: Prisma.CalculationTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalculationTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalculationTypeCountArgs<ExtArgs>
            result: $Utils.Optional<CalculationTypeCountAggregateOutputType> | number
          }
        }
      }
      CalculationParameter: {
        payload: Prisma.$CalculationParameterPayload<ExtArgs>
        fields: Prisma.CalculationParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalculationParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalculationParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationParameterPayload>
          }
          findFirst: {
            args: Prisma.CalculationParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalculationParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationParameterPayload>
          }
          findMany: {
            args: Prisma.CalculationParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationParameterPayload>[]
          }
          create: {
            args: Prisma.CalculationParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationParameterPayload>
          }
          createMany: {
            args: Prisma.CalculationParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CalculationParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationParameterPayload>
          }
          update: {
            args: Prisma.CalculationParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationParameterPayload>
          }
          deleteMany: {
            args: Prisma.CalculationParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalculationParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalculationParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalculationParameterPayload>
          }
          aggregate: {
            args: Prisma.CalculationParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalculationParameter>
          }
          groupBy: {
            args: Prisma.CalculationParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalculationParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalculationParameterCountArgs<ExtArgs>
            result: $Utils.Optional<CalculationParameterCountAggregateOutputType> | number
          }
        }
      }
      ExampleCategory: {
        payload: Prisma.$ExampleCategoryPayload<ExtArgs>
        fields: Prisma.ExampleCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExampleCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExampleCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExampleCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExampleCategoryPayload>
          }
          findFirst: {
            args: Prisma.ExampleCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExampleCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExampleCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExampleCategoryPayload>
          }
          findMany: {
            args: Prisma.ExampleCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExampleCategoryPayload>[]
          }
          create: {
            args: Prisma.ExampleCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExampleCategoryPayload>
          }
          createMany: {
            args: Prisma.ExampleCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExampleCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExampleCategoryPayload>
          }
          update: {
            args: Prisma.ExampleCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExampleCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExampleCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExampleCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExampleCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExampleCategoryPayload>
          }
          aggregate: {
            args: Prisma.ExampleCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExampleCategory>
          }
          groupBy: {
            args: Prisma.ExampleCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExampleCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExampleCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExampleCategoryCountAggregateOutputType> | number
          }
        }
      }
      Example: {
        payload: Prisma.$ExamplePayload<ExtArgs>
        fields: Prisma.ExampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamplePayload>
          }
          findFirst: {
            args: Prisma.ExampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamplePayload>
          }
          findMany: {
            args: Prisma.ExampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamplePayload>[]
          }
          create: {
            args: Prisma.ExampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamplePayload>
          }
          createMany: {
            args: Prisma.ExampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamplePayload>
          }
          update: {
            args: Prisma.ExampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamplePayload>
          }
          deleteMany: {
            args: Prisma.ExampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamplePayload>
          }
          aggregate: {
            args: Prisma.ExampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExample>
          }
          groupBy: {
            args: Prisma.ExampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExampleCountArgs<ExtArgs>
            result: $Utils.Optional<ExampleCountAggregateOutputType> | number
          }
        }
      }
      ContactType: {
        payload: Prisma.$ContactTypePayload<ExtArgs>
        fields: Prisma.ContactTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          findFirst: {
            args: Prisma.ContactTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          findMany: {
            args: Prisma.ContactTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>[]
          }
          create: {
            args: Prisma.ContactTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          createMany: {
            args: Prisma.ContactTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          update: {
            args: Prisma.ContactTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          deleteMany: {
            args: Prisma.ContactTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          aggregate: {
            args: Prisma.ContactTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactType>
          }
          groupBy: {
            args: Prisma.ContactTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ContactTypeCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      DataVersion: {
        payload: Prisma.$DataVersionPayload<ExtArgs>
        fields: Prisma.DataVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataVersionPayload>
          }
          findFirst: {
            args: Prisma.DataVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataVersionPayload>
          }
          findMany: {
            args: Prisma.DataVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataVersionPayload>[]
          }
          create: {
            args: Prisma.DataVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataVersionPayload>
          }
          createMany: {
            args: Prisma.DataVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DataVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataVersionPayload>
          }
          update: {
            args: Prisma.DataVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataVersionPayload>
          }
          deleteMany: {
            args: Prisma.DataVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataVersionPayload>
          }
          aggregate: {
            args: Prisma.DataVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataVersion>
          }
          groupBy: {
            args: Prisma.DataVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataVersionCountArgs<ExtArgs>
            result: $Utils.Optional<DataVersionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    canton?: CantonOmit
    regulationCategory?: RegulationCategoryOmit
    regulation?: RegulationOmit
    calculationType?: CalculationTypeOmit
    calculationParameter?: CalculationParameterOmit
    exampleCategory?: ExampleCategoryOmit
    example?: ExampleOmit
    contactType?: ContactTypeOmit
    contact?: ContactOmit
    dataVersion?: DataVersionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CantonCountOutputType
   */

  export type CantonCountOutputType = {
    regulations: number
    contacts: number
    calculationParams: number
    examples: number
  }

  export type CantonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regulations?: boolean | CantonCountOutputTypeCountRegulationsArgs
    contacts?: boolean | CantonCountOutputTypeCountContactsArgs
    calculationParams?: boolean | CantonCountOutputTypeCountCalculationParamsArgs
    examples?: boolean | CantonCountOutputTypeCountExamplesArgs
  }

  // Custom InputTypes
  /**
   * CantonCountOutputType without action
   */
  export type CantonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CantonCountOutputType
     */
    select?: CantonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CantonCountOutputType without action
   */
  export type CantonCountOutputTypeCountRegulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegulationWhereInput
  }

  /**
   * CantonCountOutputType without action
   */
  export type CantonCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * CantonCountOutputType without action
   */
  export type CantonCountOutputTypeCountCalculationParamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalculationParameterWhereInput
  }

  /**
   * CantonCountOutputType without action
   */
  export type CantonCountOutputTypeCountExamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExampleWhereInput
  }


  /**
   * Count Type RegulationCategoryCountOutputType
   */

  export type RegulationCategoryCountOutputType = {
    regulations: number
  }

  export type RegulationCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regulations?: boolean | RegulationCategoryCountOutputTypeCountRegulationsArgs
  }

  // Custom InputTypes
  /**
   * RegulationCategoryCountOutputType without action
   */
  export type RegulationCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategoryCountOutputType
     */
    select?: RegulationCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegulationCategoryCountOutputType without action
   */
  export type RegulationCategoryCountOutputTypeCountRegulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegulationWhereInput
  }


  /**
   * Count Type CalculationTypeCountOutputType
   */

  export type CalculationTypeCountOutputType = {
    parameters: number
  }

  export type CalculationTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameters?: boolean | CalculationTypeCountOutputTypeCountParametersArgs
  }

  // Custom InputTypes
  /**
   * CalculationTypeCountOutputType without action
   */
  export type CalculationTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationTypeCountOutputType
     */
    select?: CalculationTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalculationTypeCountOutputType without action
   */
  export type CalculationTypeCountOutputTypeCountParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalculationParameterWhereInput
  }


  /**
   * Count Type ExampleCategoryCountOutputType
   */

  export type ExampleCategoryCountOutputType = {
    examples: number
  }

  export type ExampleCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examples?: boolean | ExampleCategoryCountOutputTypeCountExamplesArgs
  }

  // Custom InputTypes
  /**
   * ExampleCategoryCountOutputType without action
   */
  export type ExampleCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategoryCountOutputType
     */
    select?: ExampleCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExampleCategoryCountOutputType without action
   */
  export type ExampleCategoryCountOutputTypeCountExamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExampleWhereInput
  }


  /**
   * Count Type ContactTypeCountOutputType
   */

  export type ContactTypeCountOutputType = {
    contacts: number
  }

  export type ContactTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | ContactTypeCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * ContactTypeCountOutputType without action
   */
  export type ContactTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTypeCountOutputType
     */
    select?: ContactTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactTypeCountOutputType without action
   */
  export type ContactTypeCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Canton
   */

  export type AggregateCanton = {
    _count: CantonCountAggregateOutputType | null
    _avg: CantonAvgAggregateOutputType | null
    _sum: CantonSumAggregateOutputType | null
    _min: CantonMinAggregateOutputType | null
    _max: CantonMaxAggregateOutputType | null
  }

  export type CantonAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type CantonSumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type CantonMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    nameOfficial: string | null
    coatOfArms: string | null
    language: $Enums.CantonLanguage | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CantonMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    nameOfficial: string | null
    coatOfArms: string | null
    language: $Enums.CantonLanguage | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CantonCountAggregateOutputType = {
    id: number
    code: number
    name: number
    nameOfficial: number
    coatOfArms: number
    language: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CantonAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type CantonSumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type CantonMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameOfficial?: true
    coatOfArms?: true
    language?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CantonMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameOfficial?: true
    coatOfArms?: true
    language?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CantonCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameOfficial?: true
    coatOfArms?: true
    language?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CantonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canton to aggregate.
     */
    where?: CantonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cantons to fetch.
     */
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CantonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cantons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cantons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cantons
    **/
    _count?: true | CantonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CantonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CantonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CantonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CantonMaxAggregateInputType
  }

  export type GetCantonAggregateType<T extends CantonAggregateArgs> = {
        [P in keyof T & keyof AggregateCanton]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanton[P]>
      : GetScalarType<T[P], AggregateCanton[P]>
  }




  export type CantonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CantonWhereInput
    orderBy?: CantonOrderByWithAggregationInput | CantonOrderByWithAggregationInput[]
    by: CantonScalarFieldEnum[] | CantonScalarFieldEnum
    having?: CantonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CantonCountAggregateInputType | true
    _avg?: CantonAvgAggregateInputType
    _sum?: CantonSumAggregateInputType
    _min?: CantonMinAggregateInputType
    _max?: CantonMaxAggregateInputType
  }

  export type CantonGroupByOutputType = {
    id: number
    code: string
    name: string
    nameOfficial: string
    coatOfArms: string | null
    language: $Enums.CantonLanguage
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: CantonCountAggregateOutputType | null
    _avg: CantonAvgAggregateOutputType | null
    _sum: CantonSumAggregateOutputType | null
    _min: CantonMinAggregateOutputType | null
    _max: CantonMaxAggregateOutputType | null
  }

  type GetCantonGroupByPayload<T extends CantonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CantonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CantonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CantonGroupByOutputType[P]>
            : GetScalarType<T[P], CantonGroupByOutputType[P]>
        }
      >
    >


  export type CantonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    nameOfficial?: boolean
    coatOfArms?: boolean
    language?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    regulations?: boolean | Canton$regulationsArgs<ExtArgs>
    contacts?: boolean | Canton$contactsArgs<ExtArgs>
    calculationParams?: boolean | Canton$calculationParamsArgs<ExtArgs>
    examples?: boolean | Canton$examplesArgs<ExtArgs>
    _count?: boolean | CantonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canton"]>



  export type CantonSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    nameOfficial?: boolean
    coatOfArms?: boolean
    language?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CantonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "nameOfficial" | "coatOfArms" | "language" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["canton"]>
  export type CantonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regulations?: boolean | Canton$regulationsArgs<ExtArgs>
    contacts?: boolean | Canton$contactsArgs<ExtArgs>
    calculationParams?: boolean | Canton$calculationParamsArgs<ExtArgs>
    examples?: boolean | Canton$examplesArgs<ExtArgs>
    _count?: boolean | CantonCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CantonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Canton"
    objects: {
      regulations: Prisma.$RegulationPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      calculationParams: Prisma.$CalculationParameterPayload<ExtArgs>[]
      examples: Prisma.$ExamplePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      nameOfficial: string
      coatOfArms: string | null
      language: $Enums.CantonLanguage
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["canton"]>
    composites: {}
  }

  type CantonGetPayload<S extends boolean | null | undefined | CantonDefaultArgs> = $Result.GetResult<Prisma.$CantonPayload, S>

  type CantonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CantonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CantonCountAggregateInputType | true
    }

  export interface CantonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Canton'], meta: { name: 'Canton' } }
    /**
     * Find zero or one Canton that matches the filter.
     * @param {CantonFindUniqueArgs} args - Arguments to find a Canton
     * @example
     * // Get one Canton
     * const canton = await prisma.canton.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CantonFindUniqueArgs>(args: SelectSubset<T, CantonFindUniqueArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Canton that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CantonFindUniqueOrThrowArgs} args - Arguments to find a Canton
     * @example
     * // Get one Canton
     * const canton = await prisma.canton.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CantonFindUniqueOrThrowArgs>(args: SelectSubset<T, CantonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Canton that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonFindFirstArgs} args - Arguments to find a Canton
     * @example
     * // Get one Canton
     * const canton = await prisma.canton.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CantonFindFirstArgs>(args?: SelectSubset<T, CantonFindFirstArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Canton that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonFindFirstOrThrowArgs} args - Arguments to find a Canton
     * @example
     * // Get one Canton
     * const canton = await prisma.canton.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CantonFindFirstOrThrowArgs>(args?: SelectSubset<T, CantonFindFirstOrThrowArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cantons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cantons
     * const cantons = await prisma.canton.findMany()
     * 
     * // Get first 10 Cantons
     * const cantons = await prisma.canton.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cantonWithIdOnly = await prisma.canton.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CantonFindManyArgs>(args?: SelectSubset<T, CantonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Canton.
     * @param {CantonCreateArgs} args - Arguments to create a Canton.
     * @example
     * // Create one Canton
     * const Canton = await prisma.canton.create({
     *   data: {
     *     // ... data to create a Canton
     *   }
     * })
     * 
     */
    create<T extends CantonCreateArgs>(args: SelectSubset<T, CantonCreateArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cantons.
     * @param {CantonCreateManyArgs} args - Arguments to create many Cantons.
     * @example
     * // Create many Cantons
     * const canton = await prisma.canton.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CantonCreateManyArgs>(args?: SelectSubset<T, CantonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Canton.
     * @param {CantonDeleteArgs} args - Arguments to delete one Canton.
     * @example
     * // Delete one Canton
     * const Canton = await prisma.canton.delete({
     *   where: {
     *     // ... filter to delete one Canton
     *   }
     * })
     * 
     */
    delete<T extends CantonDeleteArgs>(args: SelectSubset<T, CantonDeleteArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Canton.
     * @param {CantonUpdateArgs} args - Arguments to update one Canton.
     * @example
     * // Update one Canton
     * const canton = await prisma.canton.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CantonUpdateArgs>(args: SelectSubset<T, CantonUpdateArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cantons.
     * @param {CantonDeleteManyArgs} args - Arguments to filter Cantons to delete.
     * @example
     * // Delete a few Cantons
     * const { count } = await prisma.canton.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CantonDeleteManyArgs>(args?: SelectSubset<T, CantonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cantons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cantons
     * const canton = await prisma.canton.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CantonUpdateManyArgs>(args: SelectSubset<T, CantonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Canton.
     * @param {CantonUpsertArgs} args - Arguments to update or create a Canton.
     * @example
     * // Update or create a Canton
     * const canton = await prisma.canton.upsert({
     *   create: {
     *     // ... data to create a Canton
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Canton we want to update
     *   }
     * })
     */
    upsert<T extends CantonUpsertArgs>(args: SelectSubset<T, CantonUpsertArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cantons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonCountArgs} args - Arguments to filter Cantons to count.
     * @example
     * // Count the number of Cantons
     * const count = await prisma.canton.count({
     *   where: {
     *     // ... the filter for the Cantons we want to count
     *   }
     * })
    **/
    count<T extends CantonCountArgs>(
      args?: Subset<T, CantonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CantonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Canton.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CantonAggregateArgs>(args: Subset<T, CantonAggregateArgs>): Prisma.PrismaPromise<GetCantonAggregateType<T>>

    /**
     * Group by Canton.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CantonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CantonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CantonGroupByArgs['orderBy'] }
        : { orderBy?: CantonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CantonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCantonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Canton model
   */
  readonly fields: CantonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Canton.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CantonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    regulations<T extends Canton$regulationsArgs<ExtArgs> = {}>(args?: Subset<T, Canton$regulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Canton$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Canton$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calculationParams<T extends Canton$calculationParamsArgs<ExtArgs> = {}>(args?: Subset<T, Canton$calculationParamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examples<T extends Canton$examplesArgs<ExtArgs> = {}>(args?: Subset<T, Canton$examplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Canton model
   */
  interface CantonFieldRefs {
    readonly id: FieldRef<"Canton", 'Int'>
    readonly code: FieldRef<"Canton", 'String'>
    readonly name: FieldRef<"Canton", 'String'>
    readonly nameOfficial: FieldRef<"Canton", 'String'>
    readonly coatOfArms: FieldRef<"Canton", 'String'>
    readonly language: FieldRef<"Canton", 'CantonLanguage'>
    readonly sortOrder: FieldRef<"Canton", 'Int'>
    readonly createdAt: FieldRef<"Canton", 'DateTime'>
    readonly updatedAt: FieldRef<"Canton", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Canton findUnique
   */
  export type CantonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Canton to fetch.
     */
    where: CantonWhereUniqueInput
  }

  /**
   * Canton findUniqueOrThrow
   */
  export type CantonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Canton to fetch.
     */
    where: CantonWhereUniqueInput
  }

  /**
   * Canton findFirst
   */
  export type CantonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Canton to fetch.
     */
    where?: CantonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cantons to fetch.
     */
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cantons.
     */
    cursor?: CantonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cantons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cantons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cantons.
     */
    distinct?: CantonScalarFieldEnum | CantonScalarFieldEnum[]
  }

  /**
   * Canton findFirstOrThrow
   */
  export type CantonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Canton to fetch.
     */
    where?: CantonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cantons to fetch.
     */
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cantons.
     */
    cursor?: CantonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cantons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cantons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cantons.
     */
    distinct?: CantonScalarFieldEnum | CantonScalarFieldEnum[]
  }

  /**
   * Canton findMany
   */
  export type CantonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter, which Cantons to fetch.
     */
    where?: CantonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cantons to fetch.
     */
    orderBy?: CantonOrderByWithRelationInput | CantonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cantons.
     */
    cursor?: CantonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cantons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cantons.
     */
    skip?: number
    distinct?: CantonScalarFieldEnum | CantonScalarFieldEnum[]
  }

  /**
   * Canton create
   */
  export type CantonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * The data needed to create a Canton.
     */
    data: XOR<CantonCreateInput, CantonUncheckedCreateInput>
  }

  /**
   * Canton createMany
   */
  export type CantonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cantons.
     */
    data: CantonCreateManyInput | CantonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Canton update
   */
  export type CantonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * The data needed to update a Canton.
     */
    data: XOR<CantonUpdateInput, CantonUncheckedUpdateInput>
    /**
     * Choose, which Canton to update.
     */
    where: CantonWhereUniqueInput
  }

  /**
   * Canton updateMany
   */
  export type CantonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cantons.
     */
    data: XOR<CantonUpdateManyMutationInput, CantonUncheckedUpdateManyInput>
    /**
     * Filter which Cantons to update
     */
    where?: CantonWhereInput
    /**
     * Limit how many Cantons to update.
     */
    limit?: number
  }

  /**
   * Canton upsert
   */
  export type CantonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * The filter to search for the Canton to update in case it exists.
     */
    where: CantonWhereUniqueInput
    /**
     * In case the Canton found by the `where` argument doesn't exist, create a new Canton with this data.
     */
    create: XOR<CantonCreateInput, CantonUncheckedCreateInput>
    /**
     * In case the Canton was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CantonUpdateInput, CantonUncheckedUpdateInput>
  }

  /**
   * Canton delete
   */
  export type CantonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    /**
     * Filter which Canton to delete.
     */
    where: CantonWhereUniqueInput
  }

  /**
   * Canton deleteMany
   */
  export type CantonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cantons to delete
     */
    where?: CantonWhereInput
    /**
     * Limit how many Cantons to delete.
     */
    limit?: number
  }

  /**
   * Canton.regulations
   */
  export type Canton$regulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    where?: RegulationWhereInput
    orderBy?: RegulationOrderByWithRelationInput | RegulationOrderByWithRelationInput[]
    cursor?: RegulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegulationScalarFieldEnum | RegulationScalarFieldEnum[]
  }

  /**
   * Canton.contacts
   */
  export type Canton$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Canton.calculationParams
   */
  export type Canton$calculationParamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    where?: CalculationParameterWhereInput
    orderBy?: CalculationParameterOrderByWithRelationInput | CalculationParameterOrderByWithRelationInput[]
    cursor?: CalculationParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalculationParameterScalarFieldEnum | CalculationParameterScalarFieldEnum[]
  }

  /**
   * Canton.examples
   */
  export type Canton$examplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    where?: ExampleWhereInput
    orderBy?: ExampleOrderByWithRelationInput | ExampleOrderByWithRelationInput[]
    cursor?: ExampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExampleScalarFieldEnum | ExampleScalarFieldEnum[]
  }

  /**
   * Canton without action
   */
  export type CantonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
  }


  /**
   * Model RegulationCategory
   */

  export type AggregateRegulationCategory = {
    _count: RegulationCategoryCountAggregateOutputType | null
    _avg: RegulationCategoryAvgAggregateOutputType | null
    _sum: RegulationCategorySumAggregateOutputType | null
    _min: RegulationCategoryMinAggregateOutputType | null
    _max: RegulationCategoryMaxAggregateOutputType | null
  }

  export type RegulationCategoryAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type RegulationCategorySumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type RegulationCategoryMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    description: string | null
    icon: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegulationCategoryMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    description: string | null
    icon: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegulationCategoryCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    icon: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RegulationCategoryAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type RegulationCategorySumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type RegulationCategoryMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    icon?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegulationCategoryMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    icon?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegulationCategoryCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    icon?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RegulationCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegulationCategory to aggregate.
     */
    where?: RegulationCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegulationCategories to fetch.
     */
    orderBy?: RegulationCategoryOrderByWithRelationInput | RegulationCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegulationCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegulationCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegulationCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegulationCategories
    **/
    _count?: true | RegulationCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegulationCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegulationCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegulationCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegulationCategoryMaxAggregateInputType
  }

  export type GetRegulationCategoryAggregateType<T extends RegulationCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRegulationCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegulationCategory[P]>
      : GetScalarType<T[P], AggregateRegulationCategory[P]>
  }




  export type RegulationCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegulationCategoryWhereInput
    orderBy?: RegulationCategoryOrderByWithAggregationInput | RegulationCategoryOrderByWithAggregationInput[]
    by: RegulationCategoryScalarFieldEnum[] | RegulationCategoryScalarFieldEnum
    having?: RegulationCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegulationCategoryCountAggregateInputType | true
    _avg?: RegulationCategoryAvgAggregateInputType
    _sum?: RegulationCategorySumAggregateInputType
    _min?: RegulationCategoryMinAggregateInputType
    _max?: RegulationCategoryMaxAggregateInputType
  }

  export type RegulationCategoryGroupByOutputType = {
    id: number
    slug: string
    name: string
    description: string | null
    icon: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: RegulationCategoryCountAggregateOutputType | null
    _avg: RegulationCategoryAvgAggregateOutputType | null
    _sum: RegulationCategorySumAggregateOutputType | null
    _min: RegulationCategoryMinAggregateOutputType | null
    _max: RegulationCategoryMaxAggregateOutputType | null
  }

  type GetRegulationCategoryGroupByPayload<T extends RegulationCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegulationCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegulationCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegulationCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], RegulationCategoryGroupByOutputType[P]>
        }
      >
    >


  export type RegulationCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    regulations?: boolean | RegulationCategory$regulationsArgs<ExtArgs>
    _count?: boolean | RegulationCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regulationCategory"]>



  export type RegulationCategorySelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RegulationCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "description" | "icon" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["regulationCategory"]>
  export type RegulationCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regulations?: boolean | RegulationCategory$regulationsArgs<ExtArgs>
    _count?: boolean | RegulationCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RegulationCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegulationCategory"
    objects: {
      regulations: Prisma.$RegulationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      name: string
      description: string | null
      icon: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["regulationCategory"]>
    composites: {}
  }

  type RegulationCategoryGetPayload<S extends boolean | null | undefined | RegulationCategoryDefaultArgs> = $Result.GetResult<Prisma.$RegulationCategoryPayload, S>

  type RegulationCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegulationCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegulationCategoryCountAggregateInputType | true
    }

  export interface RegulationCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegulationCategory'], meta: { name: 'RegulationCategory' } }
    /**
     * Find zero or one RegulationCategory that matches the filter.
     * @param {RegulationCategoryFindUniqueArgs} args - Arguments to find a RegulationCategory
     * @example
     * // Get one RegulationCategory
     * const regulationCategory = await prisma.regulationCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegulationCategoryFindUniqueArgs>(args: SelectSubset<T, RegulationCategoryFindUniqueArgs<ExtArgs>>): Prisma__RegulationCategoryClient<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegulationCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegulationCategoryFindUniqueOrThrowArgs} args - Arguments to find a RegulationCategory
     * @example
     * // Get one RegulationCategory
     * const regulationCategory = await prisma.regulationCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegulationCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RegulationCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegulationCategoryClient<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegulationCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationCategoryFindFirstArgs} args - Arguments to find a RegulationCategory
     * @example
     * // Get one RegulationCategory
     * const regulationCategory = await prisma.regulationCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegulationCategoryFindFirstArgs>(args?: SelectSubset<T, RegulationCategoryFindFirstArgs<ExtArgs>>): Prisma__RegulationCategoryClient<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegulationCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationCategoryFindFirstOrThrowArgs} args - Arguments to find a RegulationCategory
     * @example
     * // Get one RegulationCategory
     * const regulationCategory = await prisma.regulationCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegulationCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RegulationCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegulationCategoryClient<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegulationCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegulationCategories
     * const regulationCategories = await prisma.regulationCategory.findMany()
     * 
     * // Get first 10 RegulationCategories
     * const regulationCategories = await prisma.regulationCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regulationCategoryWithIdOnly = await prisma.regulationCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegulationCategoryFindManyArgs>(args?: SelectSubset<T, RegulationCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegulationCategory.
     * @param {RegulationCategoryCreateArgs} args - Arguments to create a RegulationCategory.
     * @example
     * // Create one RegulationCategory
     * const RegulationCategory = await prisma.regulationCategory.create({
     *   data: {
     *     // ... data to create a RegulationCategory
     *   }
     * })
     * 
     */
    create<T extends RegulationCategoryCreateArgs>(args: SelectSubset<T, RegulationCategoryCreateArgs<ExtArgs>>): Prisma__RegulationCategoryClient<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegulationCategories.
     * @param {RegulationCategoryCreateManyArgs} args - Arguments to create many RegulationCategories.
     * @example
     * // Create many RegulationCategories
     * const regulationCategory = await prisma.regulationCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegulationCategoryCreateManyArgs>(args?: SelectSubset<T, RegulationCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RegulationCategory.
     * @param {RegulationCategoryDeleteArgs} args - Arguments to delete one RegulationCategory.
     * @example
     * // Delete one RegulationCategory
     * const RegulationCategory = await prisma.regulationCategory.delete({
     *   where: {
     *     // ... filter to delete one RegulationCategory
     *   }
     * })
     * 
     */
    delete<T extends RegulationCategoryDeleteArgs>(args: SelectSubset<T, RegulationCategoryDeleteArgs<ExtArgs>>): Prisma__RegulationCategoryClient<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegulationCategory.
     * @param {RegulationCategoryUpdateArgs} args - Arguments to update one RegulationCategory.
     * @example
     * // Update one RegulationCategory
     * const regulationCategory = await prisma.regulationCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegulationCategoryUpdateArgs>(args: SelectSubset<T, RegulationCategoryUpdateArgs<ExtArgs>>): Prisma__RegulationCategoryClient<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegulationCategories.
     * @param {RegulationCategoryDeleteManyArgs} args - Arguments to filter RegulationCategories to delete.
     * @example
     * // Delete a few RegulationCategories
     * const { count } = await prisma.regulationCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegulationCategoryDeleteManyArgs>(args?: SelectSubset<T, RegulationCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegulationCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegulationCategories
     * const regulationCategory = await prisma.regulationCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegulationCategoryUpdateManyArgs>(args: SelectSubset<T, RegulationCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RegulationCategory.
     * @param {RegulationCategoryUpsertArgs} args - Arguments to update or create a RegulationCategory.
     * @example
     * // Update or create a RegulationCategory
     * const regulationCategory = await prisma.regulationCategory.upsert({
     *   create: {
     *     // ... data to create a RegulationCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegulationCategory we want to update
     *   }
     * })
     */
    upsert<T extends RegulationCategoryUpsertArgs>(args: SelectSubset<T, RegulationCategoryUpsertArgs<ExtArgs>>): Prisma__RegulationCategoryClient<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegulationCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationCategoryCountArgs} args - Arguments to filter RegulationCategories to count.
     * @example
     * // Count the number of RegulationCategories
     * const count = await prisma.regulationCategory.count({
     *   where: {
     *     // ... the filter for the RegulationCategories we want to count
     *   }
     * })
    **/
    count<T extends RegulationCategoryCountArgs>(
      args?: Subset<T, RegulationCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegulationCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegulationCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegulationCategoryAggregateArgs>(args: Subset<T, RegulationCategoryAggregateArgs>): Prisma.PrismaPromise<GetRegulationCategoryAggregateType<T>>

    /**
     * Group by RegulationCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegulationCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegulationCategoryGroupByArgs['orderBy'] }
        : { orderBy?: RegulationCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegulationCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegulationCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegulationCategory model
   */
  readonly fields: RegulationCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegulationCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegulationCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    regulations<T extends RegulationCategory$regulationsArgs<ExtArgs> = {}>(args?: Subset<T, RegulationCategory$regulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegulationCategory model
   */
  interface RegulationCategoryFieldRefs {
    readonly id: FieldRef<"RegulationCategory", 'Int'>
    readonly slug: FieldRef<"RegulationCategory", 'String'>
    readonly name: FieldRef<"RegulationCategory", 'String'>
    readonly description: FieldRef<"RegulationCategory", 'String'>
    readonly icon: FieldRef<"RegulationCategory", 'String'>
    readonly sortOrder: FieldRef<"RegulationCategory", 'Int'>
    readonly createdAt: FieldRef<"RegulationCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"RegulationCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RegulationCategory findUnique
   */
  export type RegulationCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegulationCategory to fetch.
     */
    where: RegulationCategoryWhereUniqueInput
  }

  /**
   * RegulationCategory findUniqueOrThrow
   */
  export type RegulationCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegulationCategory to fetch.
     */
    where: RegulationCategoryWhereUniqueInput
  }

  /**
   * RegulationCategory findFirst
   */
  export type RegulationCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegulationCategory to fetch.
     */
    where?: RegulationCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegulationCategories to fetch.
     */
    orderBy?: RegulationCategoryOrderByWithRelationInput | RegulationCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegulationCategories.
     */
    cursor?: RegulationCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegulationCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegulationCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegulationCategories.
     */
    distinct?: RegulationCategoryScalarFieldEnum | RegulationCategoryScalarFieldEnum[]
  }

  /**
   * RegulationCategory findFirstOrThrow
   */
  export type RegulationCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegulationCategory to fetch.
     */
    where?: RegulationCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegulationCategories to fetch.
     */
    orderBy?: RegulationCategoryOrderByWithRelationInput | RegulationCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegulationCategories.
     */
    cursor?: RegulationCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegulationCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegulationCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegulationCategories.
     */
    distinct?: RegulationCategoryScalarFieldEnum | RegulationCategoryScalarFieldEnum[]
  }

  /**
   * RegulationCategory findMany
   */
  export type RegulationCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
    /**
     * Filter, which RegulationCategories to fetch.
     */
    where?: RegulationCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegulationCategories to fetch.
     */
    orderBy?: RegulationCategoryOrderByWithRelationInput | RegulationCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegulationCategories.
     */
    cursor?: RegulationCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegulationCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegulationCategories.
     */
    skip?: number
    distinct?: RegulationCategoryScalarFieldEnum | RegulationCategoryScalarFieldEnum[]
  }

  /**
   * RegulationCategory create
   */
  export type RegulationCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RegulationCategory.
     */
    data: XOR<RegulationCategoryCreateInput, RegulationCategoryUncheckedCreateInput>
  }

  /**
   * RegulationCategory createMany
   */
  export type RegulationCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegulationCategories.
     */
    data: RegulationCategoryCreateManyInput | RegulationCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegulationCategory update
   */
  export type RegulationCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RegulationCategory.
     */
    data: XOR<RegulationCategoryUpdateInput, RegulationCategoryUncheckedUpdateInput>
    /**
     * Choose, which RegulationCategory to update.
     */
    where: RegulationCategoryWhereUniqueInput
  }

  /**
   * RegulationCategory updateMany
   */
  export type RegulationCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegulationCategories.
     */
    data: XOR<RegulationCategoryUpdateManyMutationInput, RegulationCategoryUncheckedUpdateManyInput>
    /**
     * Filter which RegulationCategories to update
     */
    where?: RegulationCategoryWhereInput
    /**
     * Limit how many RegulationCategories to update.
     */
    limit?: number
  }

  /**
   * RegulationCategory upsert
   */
  export type RegulationCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RegulationCategory to update in case it exists.
     */
    where: RegulationCategoryWhereUniqueInput
    /**
     * In case the RegulationCategory found by the `where` argument doesn't exist, create a new RegulationCategory with this data.
     */
    create: XOR<RegulationCategoryCreateInput, RegulationCategoryUncheckedCreateInput>
    /**
     * In case the RegulationCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegulationCategoryUpdateInput, RegulationCategoryUncheckedUpdateInput>
  }

  /**
   * RegulationCategory delete
   */
  export type RegulationCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
    /**
     * Filter which RegulationCategory to delete.
     */
    where: RegulationCategoryWhereUniqueInput
  }

  /**
   * RegulationCategory deleteMany
   */
  export type RegulationCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegulationCategories to delete
     */
    where?: RegulationCategoryWhereInput
    /**
     * Limit how many RegulationCategories to delete.
     */
    limit?: number
  }

  /**
   * RegulationCategory.regulations
   */
  export type RegulationCategory$regulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    where?: RegulationWhereInput
    orderBy?: RegulationOrderByWithRelationInput | RegulationOrderByWithRelationInput[]
    cursor?: RegulationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegulationScalarFieldEnum | RegulationScalarFieldEnum[]
  }

  /**
   * RegulationCategory without action
   */
  export type RegulationCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegulationCategory
     */
    select?: RegulationCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegulationCategory
     */
    omit?: RegulationCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Regulation
   */

  export type AggregateRegulation = {
    _count: RegulationCountAggregateOutputType | null
    _avg: RegulationAvgAggregateOutputType | null
    _sum: RegulationSumAggregateOutputType | null
    _min: RegulationMinAggregateOutputType | null
    _max: RegulationMaxAggregateOutputType | null
  }

  export type RegulationAvgAggregateOutputType = {
    id: number | null
    cantonId: number | null
    categoryId: number | null
    version: number | null
    sortOrder: number | null
  }

  export type RegulationSumAggregateOutputType = {
    id: number | null
    cantonId: number | null
    categoryId: number | null
    version: number | null
    sortOrder: number | null
  }

  export type RegulationMinAggregateOutputType = {
    id: number | null
    cantonId: number | null
    categoryId: number | null
    title: string | null
    summary: string | null
    content: string | null
    legalReference: string | null
    sourceUrl: string | null
    effectiveDate: Date | null
    isActive: boolean | null
    version: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegulationMaxAggregateOutputType = {
    id: number | null
    cantonId: number | null
    categoryId: number | null
    title: string | null
    summary: string | null
    content: string | null
    legalReference: string | null
    sourceUrl: string | null
    effectiveDate: Date | null
    isActive: boolean | null
    version: number | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegulationCountAggregateOutputType = {
    id: number
    cantonId: number
    categoryId: number
    title: number
    summary: number
    content: number
    legalReference: number
    sourceUrl: number
    effectiveDate: number
    isActive: number
    version: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RegulationAvgAggregateInputType = {
    id?: true
    cantonId?: true
    categoryId?: true
    version?: true
    sortOrder?: true
  }

  export type RegulationSumAggregateInputType = {
    id?: true
    cantonId?: true
    categoryId?: true
    version?: true
    sortOrder?: true
  }

  export type RegulationMinAggregateInputType = {
    id?: true
    cantonId?: true
    categoryId?: true
    title?: true
    summary?: true
    content?: true
    legalReference?: true
    sourceUrl?: true
    effectiveDate?: true
    isActive?: true
    version?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegulationMaxAggregateInputType = {
    id?: true
    cantonId?: true
    categoryId?: true
    title?: true
    summary?: true
    content?: true
    legalReference?: true
    sourceUrl?: true
    effectiveDate?: true
    isActive?: true
    version?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegulationCountAggregateInputType = {
    id?: true
    cantonId?: true
    categoryId?: true
    title?: true
    summary?: true
    content?: true
    legalReference?: true
    sourceUrl?: true
    effectiveDate?: true
    isActive?: true
    version?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RegulationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regulation to aggregate.
     */
    where?: RegulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regulations to fetch.
     */
    orderBy?: RegulationOrderByWithRelationInput | RegulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regulations
    **/
    _count?: true | RegulationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegulationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegulationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegulationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegulationMaxAggregateInputType
  }

  export type GetRegulationAggregateType<T extends RegulationAggregateArgs> = {
        [P in keyof T & keyof AggregateRegulation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegulation[P]>
      : GetScalarType<T[P], AggregateRegulation[P]>
  }




  export type RegulationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegulationWhereInput
    orderBy?: RegulationOrderByWithAggregationInput | RegulationOrderByWithAggregationInput[]
    by: RegulationScalarFieldEnum[] | RegulationScalarFieldEnum
    having?: RegulationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegulationCountAggregateInputType | true
    _avg?: RegulationAvgAggregateInputType
    _sum?: RegulationSumAggregateInputType
    _min?: RegulationMinAggregateInputType
    _max?: RegulationMaxAggregateInputType
  }

  export type RegulationGroupByOutputType = {
    id: number
    cantonId: number
    categoryId: number
    title: string
    summary: string
    content: string
    legalReference: string | null
    sourceUrl: string | null
    effectiveDate: Date | null
    isActive: boolean
    version: number
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: RegulationCountAggregateOutputType | null
    _avg: RegulationAvgAggregateOutputType | null
    _sum: RegulationSumAggregateOutputType | null
    _min: RegulationMinAggregateOutputType | null
    _max: RegulationMaxAggregateOutputType | null
  }

  type GetRegulationGroupByPayload<T extends RegulationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegulationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegulationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegulationGroupByOutputType[P]>
            : GetScalarType<T[P], RegulationGroupByOutputType[P]>
        }
      >
    >


  export type RegulationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cantonId?: boolean
    categoryId?: boolean
    title?: boolean
    summary?: boolean
    content?: boolean
    legalReference?: boolean
    sourceUrl?: boolean
    effectiveDate?: boolean
    isActive?: boolean
    version?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canton?: boolean | CantonDefaultArgs<ExtArgs>
    category?: boolean | RegulationCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regulation"]>



  export type RegulationSelectScalar = {
    id?: boolean
    cantonId?: boolean
    categoryId?: boolean
    title?: boolean
    summary?: boolean
    content?: boolean
    legalReference?: boolean
    sourceUrl?: boolean
    effectiveDate?: boolean
    isActive?: boolean
    version?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RegulationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cantonId" | "categoryId" | "title" | "summary" | "content" | "legalReference" | "sourceUrl" | "effectiveDate" | "isActive" | "version" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["regulation"]>
  export type RegulationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canton?: boolean | CantonDefaultArgs<ExtArgs>
    category?: boolean | RegulationCategoryDefaultArgs<ExtArgs>
  }

  export type $RegulationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Regulation"
    objects: {
      canton: Prisma.$CantonPayload<ExtArgs>
      category: Prisma.$RegulationCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cantonId: number
      categoryId: number
      title: string
      summary: string
      content: string
      legalReference: string | null
      sourceUrl: string | null
      effectiveDate: Date | null
      isActive: boolean
      version: number
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["regulation"]>
    composites: {}
  }

  type RegulationGetPayload<S extends boolean | null | undefined | RegulationDefaultArgs> = $Result.GetResult<Prisma.$RegulationPayload, S>

  type RegulationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegulationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegulationCountAggregateInputType | true
    }

  export interface RegulationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Regulation'], meta: { name: 'Regulation' } }
    /**
     * Find zero or one Regulation that matches the filter.
     * @param {RegulationFindUniqueArgs} args - Arguments to find a Regulation
     * @example
     * // Get one Regulation
     * const regulation = await prisma.regulation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegulationFindUniqueArgs>(args: SelectSubset<T, RegulationFindUniqueArgs<ExtArgs>>): Prisma__RegulationClient<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Regulation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegulationFindUniqueOrThrowArgs} args - Arguments to find a Regulation
     * @example
     * // Get one Regulation
     * const regulation = await prisma.regulation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegulationFindUniqueOrThrowArgs>(args: SelectSubset<T, RegulationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegulationClient<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Regulation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationFindFirstArgs} args - Arguments to find a Regulation
     * @example
     * // Get one Regulation
     * const regulation = await prisma.regulation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegulationFindFirstArgs>(args?: SelectSubset<T, RegulationFindFirstArgs<ExtArgs>>): Prisma__RegulationClient<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Regulation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationFindFirstOrThrowArgs} args - Arguments to find a Regulation
     * @example
     * // Get one Regulation
     * const regulation = await prisma.regulation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegulationFindFirstOrThrowArgs>(args?: SelectSubset<T, RegulationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegulationClient<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regulations
     * const regulations = await prisma.regulation.findMany()
     * 
     * // Get first 10 Regulations
     * const regulations = await prisma.regulation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regulationWithIdOnly = await prisma.regulation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegulationFindManyArgs>(args?: SelectSubset<T, RegulationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Regulation.
     * @param {RegulationCreateArgs} args - Arguments to create a Regulation.
     * @example
     * // Create one Regulation
     * const Regulation = await prisma.regulation.create({
     *   data: {
     *     // ... data to create a Regulation
     *   }
     * })
     * 
     */
    create<T extends RegulationCreateArgs>(args: SelectSubset<T, RegulationCreateArgs<ExtArgs>>): Prisma__RegulationClient<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regulations.
     * @param {RegulationCreateManyArgs} args - Arguments to create many Regulations.
     * @example
     * // Create many Regulations
     * const regulation = await prisma.regulation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegulationCreateManyArgs>(args?: SelectSubset<T, RegulationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Regulation.
     * @param {RegulationDeleteArgs} args - Arguments to delete one Regulation.
     * @example
     * // Delete one Regulation
     * const Regulation = await prisma.regulation.delete({
     *   where: {
     *     // ... filter to delete one Regulation
     *   }
     * })
     * 
     */
    delete<T extends RegulationDeleteArgs>(args: SelectSubset<T, RegulationDeleteArgs<ExtArgs>>): Prisma__RegulationClient<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Regulation.
     * @param {RegulationUpdateArgs} args - Arguments to update one Regulation.
     * @example
     * // Update one Regulation
     * const regulation = await prisma.regulation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegulationUpdateArgs>(args: SelectSubset<T, RegulationUpdateArgs<ExtArgs>>): Prisma__RegulationClient<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regulations.
     * @param {RegulationDeleteManyArgs} args - Arguments to filter Regulations to delete.
     * @example
     * // Delete a few Regulations
     * const { count } = await prisma.regulation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegulationDeleteManyArgs>(args?: SelectSubset<T, RegulationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regulations
     * const regulation = await prisma.regulation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegulationUpdateManyArgs>(args: SelectSubset<T, RegulationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Regulation.
     * @param {RegulationUpsertArgs} args - Arguments to update or create a Regulation.
     * @example
     * // Update or create a Regulation
     * const regulation = await prisma.regulation.upsert({
     *   create: {
     *     // ... data to create a Regulation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regulation we want to update
     *   }
     * })
     */
    upsert<T extends RegulationUpsertArgs>(args: SelectSubset<T, RegulationUpsertArgs<ExtArgs>>): Prisma__RegulationClient<$Result.GetResult<Prisma.$RegulationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationCountArgs} args - Arguments to filter Regulations to count.
     * @example
     * // Count the number of Regulations
     * const count = await prisma.regulation.count({
     *   where: {
     *     // ... the filter for the Regulations we want to count
     *   }
     * })
    **/
    count<T extends RegulationCountArgs>(
      args?: Subset<T, RegulationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegulationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegulationAggregateArgs>(args: Subset<T, RegulationAggregateArgs>): Prisma.PrismaPromise<GetRegulationAggregateType<T>>

    /**
     * Group by Regulation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegulationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegulationGroupByArgs['orderBy'] }
        : { orderBy?: RegulationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegulationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegulationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Regulation model
   */
  readonly fields: RegulationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Regulation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegulationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canton<T extends CantonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CantonDefaultArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends RegulationCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegulationCategoryDefaultArgs<ExtArgs>>): Prisma__RegulationCategoryClient<$Result.GetResult<Prisma.$RegulationCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Regulation model
   */
  interface RegulationFieldRefs {
    readonly id: FieldRef<"Regulation", 'Int'>
    readonly cantonId: FieldRef<"Regulation", 'Int'>
    readonly categoryId: FieldRef<"Regulation", 'Int'>
    readonly title: FieldRef<"Regulation", 'String'>
    readonly summary: FieldRef<"Regulation", 'String'>
    readonly content: FieldRef<"Regulation", 'String'>
    readonly legalReference: FieldRef<"Regulation", 'String'>
    readonly sourceUrl: FieldRef<"Regulation", 'String'>
    readonly effectiveDate: FieldRef<"Regulation", 'DateTime'>
    readonly isActive: FieldRef<"Regulation", 'Boolean'>
    readonly version: FieldRef<"Regulation", 'Int'>
    readonly sortOrder: FieldRef<"Regulation", 'Int'>
    readonly createdAt: FieldRef<"Regulation", 'DateTime'>
    readonly updatedAt: FieldRef<"Regulation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Regulation findUnique
   */
  export type RegulationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    /**
     * Filter, which Regulation to fetch.
     */
    where: RegulationWhereUniqueInput
  }

  /**
   * Regulation findUniqueOrThrow
   */
  export type RegulationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    /**
     * Filter, which Regulation to fetch.
     */
    where: RegulationWhereUniqueInput
  }

  /**
   * Regulation findFirst
   */
  export type RegulationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    /**
     * Filter, which Regulation to fetch.
     */
    where?: RegulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regulations to fetch.
     */
    orderBy?: RegulationOrderByWithRelationInput | RegulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regulations.
     */
    cursor?: RegulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regulations.
     */
    distinct?: RegulationScalarFieldEnum | RegulationScalarFieldEnum[]
  }

  /**
   * Regulation findFirstOrThrow
   */
  export type RegulationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    /**
     * Filter, which Regulation to fetch.
     */
    where?: RegulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regulations to fetch.
     */
    orderBy?: RegulationOrderByWithRelationInput | RegulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regulations.
     */
    cursor?: RegulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regulations.
     */
    distinct?: RegulationScalarFieldEnum | RegulationScalarFieldEnum[]
  }

  /**
   * Regulation findMany
   */
  export type RegulationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    /**
     * Filter, which Regulations to fetch.
     */
    where?: RegulationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regulations to fetch.
     */
    orderBy?: RegulationOrderByWithRelationInput | RegulationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regulations.
     */
    cursor?: RegulationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regulations.
     */
    skip?: number
    distinct?: RegulationScalarFieldEnum | RegulationScalarFieldEnum[]
  }

  /**
   * Regulation create
   */
  export type RegulationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    /**
     * The data needed to create a Regulation.
     */
    data: XOR<RegulationCreateInput, RegulationUncheckedCreateInput>
  }

  /**
   * Regulation createMany
   */
  export type RegulationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regulations.
     */
    data: RegulationCreateManyInput | RegulationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Regulation update
   */
  export type RegulationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    /**
     * The data needed to update a Regulation.
     */
    data: XOR<RegulationUpdateInput, RegulationUncheckedUpdateInput>
    /**
     * Choose, which Regulation to update.
     */
    where: RegulationWhereUniqueInput
  }

  /**
   * Regulation updateMany
   */
  export type RegulationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regulations.
     */
    data: XOR<RegulationUpdateManyMutationInput, RegulationUncheckedUpdateManyInput>
    /**
     * Filter which Regulations to update
     */
    where?: RegulationWhereInput
    /**
     * Limit how many Regulations to update.
     */
    limit?: number
  }

  /**
   * Regulation upsert
   */
  export type RegulationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    /**
     * The filter to search for the Regulation to update in case it exists.
     */
    where: RegulationWhereUniqueInput
    /**
     * In case the Regulation found by the `where` argument doesn't exist, create a new Regulation with this data.
     */
    create: XOR<RegulationCreateInput, RegulationUncheckedCreateInput>
    /**
     * In case the Regulation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegulationUpdateInput, RegulationUncheckedUpdateInput>
  }

  /**
   * Regulation delete
   */
  export type RegulationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
    /**
     * Filter which Regulation to delete.
     */
    where: RegulationWhereUniqueInput
  }

  /**
   * Regulation deleteMany
   */
  export type RegulationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regulations to delete
     */
    where?: RegulationWhereInput
    /**
     * Limit how many Regulations to delete.
     */
    limit?: number
  }

  /**
   * Regulation without action
   */
  export type RegulationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regulation
     */
    select?: RegulationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Regulation
     */
    omit?: RegulationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegulationInclude<ExtArgs> | null
  }


  /**
   * Model CalculationType
   */

  export type AggregateCalculationType = {
    _count: CalculationTypeCountAggregateOutputType | null
    _avg: CalculationTypeAvgAggregateOutputType | null
    _sum: CalculationTypeSumAggregateOutputType | null
    _min: CalculationTypeMinAggregateOutputType | null
    _max: CalculationTypeMaxAggregateOutputType | null
  }

  export type CalculationTypeAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type CalculationTypeSumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type CalculationTypeMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    description: string | null
    formula: string | null
    icon: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalculationTypeMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    description: string | null
    formula: string | null
    icon: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalculationTypeCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    description: number
    formula: number
    icon: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalculationTypeAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type CalculationTypeSumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type CalculationTypeMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    formula?: true
    icon?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalculationTypeMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    formula?: true
    icon?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalculationTypeCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    formula?: true
    icon?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalculationTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalculationType to aggregate.
     */
    where?: CalculationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationTypes to fetch.
     */
    orderBy?: CalculationTypeOrderByWithRelationInput | CalculationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalculationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalculationTypes
    **/
    _count?: true | CalculationTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalculationTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalculationTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalculationTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalculationTypeMaxAggregateInputType
  }

  export type GetCalculationTypeAggregateType<T extends CalculationTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCalculationType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalculationType[P]>
      : GetScalarType<T[P], AggregateCalculationType[P]>
  }




  export type CalculationTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalculationTypeWhereInput
    orderBy?: CalculationTypeOrderByWithAggregationInput | CalculationTypeOrderByWithAggregationInput[]
    by: CalculationTypeScalarFieldEnum[] | CalculationTypeScalarFieldEnum
    having?: CalculationTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalculationTypeCountAggregateInputType | true
    _avg?: CalculationTypeAvgAggregateInputType
    _sum?: CalculationTypeSumAggregateInputType
    _min?: CalculationTypeMinAggregateInputType
    _max?: CalculationTypeMaxAggregateInputType
  }

  export type CalculationTypeGroupByOutputType = {
    id: number
    slug: string
    name: string
    description: string | null
    formula: string | null
    icon: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: CalculationTypeCountAggregateOutputType | null
    _avg: CalculationTypeAvgAggregateOutputType | null
    _sum: CalculationTypeSumAggregateOutputType | null
    _min: CalculationTypeMinAggregateOutputType | null
    _max: CalculationTypeMaxAggregateOutputType | null
  }

  type GetCalculationTypeGroupByPayload<T extends CalculationTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalculationTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalculationTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalculationTypeGroupByOutputType[P]>
            : GetScalarType<T[P], CalculationTypeGroupByOutputType[P]>
        }
      >
    >


  export type CalculationTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    formula?: boolean
    icon?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parameters?: boolean | CalculationType$parametersArgs<ExtArgs>
    _count?: boolean | CalculationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calculationType"]>



  export type CalculationTypeSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    formula?: boolean
    icon?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalculationTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "description" | "formula" | "icon" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["calculationType"]>
  export type CalculationTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parameters?: boolean | CalculationType$parametersArgs<ExtArgs>
    _count?: boolean | CalculationTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CalculationTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalculationType"
    objects: {
      parameters: Prisma.$CalculationParameterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      name: string
      description: string | null
      formula: string | null
      icon: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calculationType"]>
    composites: {}
  }

  type CalculationTypeGetPayload<S extends boolean | null | undefined | CalculationTypeDefaultArgs> = $Result.GetResult<Prisma.$CalculationTypePayload, S>

  type CalculationTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalculationTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalculationTypeCountAggregateInputType | true
    }

  export interface CalculationTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalculationType'], meta: { name: 'CalculationType' } }
    /**
     * Find zero or one CalculationType that matches the filter.
     * @param {CalculationTypeFindUniqueArgs} args - Arguments to find a CalculationType
     * @example
     * // Get one CalculationType
     * const calculationType = await prisma.calculationType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalculationTypeFindUniqueArgs>(args: SelectSubset<T, CalculationTypeFindUniqueArgs<ExtArgs>>): Prisma__CalculationTypeClient<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalculationType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalculationTypeFindUniqueOrThrowArgs} args - Arguments to find a CalculationType
     * @example
     * // Get one CalculationType
     * const calculationType = await prisma.calculationType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalculationTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, CalculationTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalculationTypeClient<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalculationType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationTypeFindFirstArgs} args - Arguments to find a CalculationType
     * @example
     * // Get one CalculationType
     * const calculationType = await prisma.calculationType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalculationTypeFindFirstArgs>(args?: SelectSubset<T, CalculationTypeFindFirstArgs<ExtArgs>>): Prisma__CalculationTypeClient<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalculationType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationTypeFindFirstOrThrowArgs} args - Arguments to find a CalculationType
     * @example
     * // Get one CalculationType
     * const calculationType = await prisma.calculationType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalculationTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, CalculationTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalculationTypeClient<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalculationTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalculationTypes
     * const calculationTypes = await prisma.calculationType.findMany()
     * 
     * // Get first 10 CalculationTypes
     * const calculationTypes = await prisma.calculationType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calculationTypeWithIdOnly = await prisma.calculationType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalculationTypeFindManyArgs>(args?: SelectSubset<T, CalculationTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalculationType.
     * @param {CalculationTypeCreateArgs} args - Arguments to create a CalculationType.
     * @example
     * // Create one CalculationType
     * const CalculationType = await prisma.calculationType.create({
     *   data: {
     *     // ... data to create a CalculationType
     *   }
     * })
     * 
     */
    create<T extends CalculationTypeCreateArgs>(args: SelectSubset<T, CalculationTypeCreateArgs<ExtArgs>>): Prisma__CalculationTypeClient<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalculationTypes.
     * @param {CalculationTypeCreateManyArgs} args - Arguments to create many CalculationTypes.
     * @example
     * // Create many CalculationTypes
     * const calculationType = await prisma.calculationType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalculationTypeCreateManyArgs>(args?: SelectSubset<T, CalculationTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CalculationType.
     * @param {CalculationTypeDeleteArgs} args - Arguments to delete one CalculationType.
     * @example
     * // Delete one CalculationType
     * const CalculationType = await prisma.calculationType.delete({
     *   where: {
     *     // ... filter to delete one CalculationType
     *   }
     * })
     * 
     */
    delete<T extends CalculationTypeDeleteArgs>(args: SelectSubset<T, CalculationTypeDeleteArgs<ExtArgs>>): Prisma__CalculationTypeClient<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalculationType.
     * @param {CalculationTypeUpdateArgs} args - Arguments to update one CalculationType.
     * @example
     * // Update one CalculationType
     * const calculationType = await prisma.calculationType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalculationTypeUpdateArgs>(args: SelectSubset<T, CalculationTypeUpdateArgs<ExtArgs>>): Prisma__CalculationTypeClient<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalculationTypes.
     * @param {CalculationTypeDeleteManyArgs} args - Arguments to filter CalculationTypes to delete.
     * @example
     * // Delete a few CalculationTypes
     * const { count } = await prisma.calculationType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalculationTypeDeleteManyArgs>(args?: SelectSubset<T, CalculationTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalculationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalculationTypes
     * const calculationType = await prisma.calculationType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalculationTypeUpdateManyArgs>(args: SelectSubset<T, CalculationTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalculationType.
     * @param {CalculationTypeUpsertArgs} args - Arguments to update or create a CalculationType.
     * @example
     * // Update or create a CalculationType
     * const calculationType = await prisma.calculationType.upsert({
     *   create: {
     *     // ... data to create a CalculationType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalculationType we want to update
     *   }
     * })
     */
    upsert<T extends CalculationTypeUpsertArgs>(args: SelectSubset<T, CalculationTypeUpsertArgs<ExtArgs>>): Prisma__CalculationTypeClient<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalculationTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationTypeCountArgs} args - Arguments to filter CalculationTypes to count.
     * @example
     * // Count the number of CalculationTypes
     * const count = await prisma.calculationType.count({
     *   where: {
     *     // ... the filter for the CalculationTypes we want to count
     *   }
     * })
    **/
    count<T extends CalculationTypeCountArgs>(
      args?: Subset<T, CalculationTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalculationTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalculationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalculationTypeAggregateArgs>(args: Subset<T, CalculationTypeAggregateArgs>): Prisma.PrismaPromise<GetCalculationTypeAggregateType<T>>

    /**
     * Group by CalculationType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalculationTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalculationTypeGroupByArgs['orderBy'] }
        : { orderBy?: CalculationTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalculationTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalculationTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalculationType model
   */
  readonly fields: CalculationTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalculationType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalculationTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parameters<T extends CalculationType$parametersArgs<ExtArgs> = {}>(args?: Subset<T, CalculationType$parametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalculationType model
   */
  interface CalculationTypeFieldRefs {
    readonly id: FieldRef<"CalculationType", 'Int'>
    readonly slug: FieldRef<"CalculationType", 'String'>
    readonly name: FieldRef<"CalculationType", 'String'>
    readonly description: FieldRef<"CalculationType", 'String'>
    readonly formula: FieldRef<"CalculationType", 'String'>
    readonly icon: FieldRef<"CalculationType", 'String'>
    readonly sortOrder: FieldRef<"CalculationType", 'Int'>
    readonly createdAt: FieldRef<"CalculationType", 'DateTime'>
    readonly updatedAt: FieldRef<"CalculationType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalculationType findUnique
   */
  export type CalculationTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
    /**
     * Filter, which CalculationType to fetch.
     */
    where: CalculationTypeWhereUniqueInput
  }

  /**
   * CalculationType findUniqueOrThrow
   */
  export type CalculationTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
    /**
     * Filter, which CalculationType to fetch.
     */
    where: CalculationTypeWhereUniqueInput
  }

  /**
   * CalculationType findFirst
   */
  export type CalculationTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
    /**
     * Filter, which CalculationType to fetch.
     */
    where?: CalculationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationTypes to fetch.
     */
    orderBy?: CalculationTypeOrderByWithRelationInput | CalculationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalculationTypes.
     */
    cursor?: CalculationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalculationTypes.
     */
    distinct?: CalculationTypeScalarFieldEnum | CalculationTypeScalarFieldEnum[]
  }

  /**
   * CalculationType findFirstOrThrow
   */
  export type CalculationTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
    /**
     * Filter, which CalculationType to fetch.
     */
    where?: CalculationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationTypes to fetch.
     */
    orderBy?: CalculationTypeOrderByWithRelationInput | CalculationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalculationTypes.
     */
    cursor?: CalculationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalculationTypes.
     */
    distinct?: CalculationTypeScalarFieldEnum | CalculationTypeScalarFieldEnum[]
  }

  /**
   * CalculationType findMany
   */
  export type CalculationTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
    /**
     * Filter, which CalculationTypes to fetch.
     */
    where?: CalculationTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationTypes to fetch.
     */
    orderBy?: CalculationTypeOrderByWithRelationInput | CalculationTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalculationTypes.
     */
    cursor?: CalculationTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationTypes.
     */
    skip?: number
    distinct?: CalculationTypeScalarFieldEnum | CalculationTypeScalarFieldEnum[]
  }

  /**
   * CalculationType create
   */
  export type CalculationTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a CalculationType.
     */
    data: XOR<CalculationTypeCreateInput, CalculationTypeUncheckedCreateInput>
  }

  /**
   * CalculationType createMany
   */
  export type CalculationTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalculationTypes.
     */
    data: CalculationTypeCreateManyInput | CalculationTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalculationType update
   */
  export type CalculationTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a CalculationType.
     */
    data: XOR<CalculationTypeUpdateInput, CalculationTypeUncheckedUpdateInput>
    /**
     * Choose, which CalculationType to update.
     */
    where: CalculationTypeWhereUniqueInput
  }

  /**
   * CalculationType updateMany
   */
  export type CalculationTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalculationTypes.
     */
    data: XOR<CalculationTypeUpdateManyMutationInput, CalculationTypeUncheckedUpdateManyInput>
    /**
     * Filter which CalculationTypes to update
     */
    where?: CalculationTypeWhereInput
    /**
     * Limit how many CalculationTypes to update.
     */
    limit?: number
  }

  /**
   * CalculationType upsert
   */
  export type CalculationTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the CalculationType to update in case it exists.
     */
    where: CalculationTypeWhereUniqueInput
    /**
     * In case the CalculationType found by the `where` argument doesn't exist, create a new CalculationType with this data.
     */
    create: XOR<CalculationTypeCreateInput, CalculationTypeUncheckedCreateInput>
    /**
     * In case the CalculationType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalculationTypeUpdateInput, CalculationTypeUncheckedUpdateInput>
  }

  /**
   * CalculationType delete
   */
  export type CalculationTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
    /**
     * Filter which CalculationType to delete.
     */
    where: CalculationTypeWhereUniqueInput
  }

  /**
   * CalculationType deleteMany
   */
  export type CalculationTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalculationTypes to delete
     */
    where?: CalculationTypeWhereInput
    /**
     * Limit how many CalculationTypes to delete.
     */
    limit?: number
  }

  /**
   * CalculationType.parameters
   */
  export type CalculationType$parametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    where?: CalculationParameterWhereInput
    orderBy?: CalculationParameterOrderByWithRelationInput | CalculationParameterOrderByWithRelationInput[]
    cursor?: CalculationParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CalculationParameterScalarFieldEnum | CalculationParameterScalarFieldEnum[]
  }

  /**
   * CalculationType without action
   */
  export type CalculationTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationType
     */
    select?: CalculationTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationType
     */
    omit?: CalculationTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationTypeInclude<ExtArgs> | null
  }


  /**
   * Model CalculationParameter
   */

  export type AggregateCalculationParameter = {
    _count: CalculationParameterCountAggregateOutputType | null
    _avg: CalculationParameterAvgAggregateOutputType | null
    _sum: CalculationParameterSumAggregateOutputType | null
    _min: CalculationParameterMinAggregateOutputType | null
    _max: CalculationParameterMaxAggregateOutputType | null
  }

  export type CalculationParameterAvgAggregateOutputType = {
    id: number | null
    calculationTypeId: number | null
    cantonId: number | null
  }

  export type CalculationParameterSumAggregateOutputType = {
    id: number | null
    calculationTypeId: number | null
    cantonId: number | null
  }

  export type CalculationParameterMinAggregateOutputType = {
    id: number | null
    calculationTypeId: number | null
    cantonId: number | null
    parameterKey: string | null
    parameterValue: string | null
    valueType: $Enums.ValueType | null
    unit: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalculationParameterMaxAggregateOutputType = {
    id: number | null
    calculationTypeId: number | null
    cantonId: number | null
    parameterKey: string | null
    parameterValue: string | null
    valueType: $Enums.ValueType | null
    unit: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalculationParameterCountAggregateOutputType = {
    id: number
    calculationTypeId: number
    cantonId: number
    parameterKey: number
    parameterValue: number
    valueType: number
    unit: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalculationParameterAvgAggregateInputType = {
    id?: true
    calculationTypeId?: true
    cantonId?: true
  }

  export type CalculationParameterSumAggregateInputType = {
    id?: true
    calculationTypeId?: true
    cantonId?: true
  }

  export type CalculationParameterMinAggregateInputType = {
    id?: true
    calculationTypeId?: true
    cantonId?: true
    parameterKey?: true
    parameterValue?: true
    valueType?: true
    unit?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalculationParameterMaxAggregateInputType = {
    id?: true
    calculationTypeId?: true
    cantonId?: true
    parameterKey?: true
    parameterValue?: true
    valueType?: true
    unit?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalculationParameterCountAggregateInputType = {
    id?: true
    calculationTypeId?: true
    cantonId?: true
    parameterKey?: true
    parameterValue?: true
    valueType?: true
    unit?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalculationParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalculationParameter to aggregate.
     */
    where?: CalculationParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationParameters to fetch.
     */
    orderBy?: CalculationParameterOrderByWithRelationInput | CalculationParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalculationParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalculationParameters
    **/
    _count?: true | CalculationParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalculationParameterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalculationParameterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalculationParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalculationParameterMaxAggregateInputType
  }

  export type GetCalculationParameterAggregateType<T extends CalculationParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateCalculationParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalculationParameter[P]>
      : GetScalarType<T[P], AggregateCalculationParameter[P]>
  }




  export type CalculationParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalculationParameterWhereInput
    orderBy?: CalculationParameterOrderByWithAggregationInput | CalculationParameterOrderByWithAggregationInput[]
    by: CalculationParameterScalarFieldEnum[] | CalculationParameterScalarFieldEnum
    having?: CalculationParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalculationParameterCountAggregateInputType | true
    _avg?: CalculationParameterAvgAggregateInputType
    _sum?: CalculationParameterSumAggregateInputType
    _min?: CalculationParameterMinAggregateInputType
    _max?: CalculationParameterMaxAggregateInputType
  }

  export type CalculationParameterGroupByOutputType = {
    id: number
    calculationTypeId: number
    cantonId: number | null
    parameterKey: string
    parameterValue: string
    valueType: $Enums.ValueType
    unit: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CalculationParameterCountAggregateOutputType | null
    _avg: CalculationParameterAvgAggregateOutputType | null
    _sum: CalculationParameterSumAggregateOutputType | null
    _min: CalculationParameterMinAggregateOutputType | null
    _max: CalculationParameterMaxAggregateOutputType | null
  }

  type GetCalculationParameterGroupByPayload<T extends CalculationParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalculationParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalculationParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalculationParameterGroupByOutputType[P]>
            : GetScalarType<T[P], CalculationParameterGroupByOutputType[P]>
        }
      >
    >


  export type CalculationParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calculationTypeId?: boolean
    cantonId?: boolean
    parameterKey?: boolean
    parameterValue?: boolean
    valueType?: boolean
    unit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    calculationType?: boolean | CalculationTypeDefaultArgs<ExtArgs>
    canton?: boolean | CalculationParameter$cantonArgs<ExtArgs>
  }, ExtArgs["result"]["calculationParameter"]>



  export type CalculationParameterSelectScalar = {
    id?: boolean
    calculationTypeId?: boolean
    cantonId?: boolean
    parameterKey?: boolean
    parameterValue?: boolean
    valueType?: boolean
    unit?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalculationParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "calculationTypeId" | "cantonId" | "parameterKey" | "parameterValue" | "valueType" | "unit" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["calculationParameter"]>
  export type CalculationParameterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calculationType?: boolean | CalculationTypeDefaultArgs<ExtArgs>
    canton?: boolean | CalculationParameter$cantonArgs<ExtArgs>
  }

  export type $CalculationParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalculationParameter"
    objects: {
      calculationType: Prisma.$CalculationTypePayload<ExtArgs>
      canton: Prisma.$CantonPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      calculationTypeId: number
      cantonId: number | null
      parameterKey: string
      parameterValue: string
      valueType: $Enums.ValueType
      unit: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calculationParameter"]>
    composites: {}
  }

  type CalculationParameterGetPayload<S extends boolean | null | undefined | CalculationParameterDefaultArgs> = $Result.GetResult<Prisma.$CalculationParameterPayload, S>

  type CalculationParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalculationParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalculationParameterCountAggregateInputType | true
    }

  export interface CalculationParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalculationParameter'], meta: { name: 'CalculationParameter' } }
    /**
     * Find zero or one CalculationParameter that matches the filter.
     * @param {CalculationParameterFindUniqueArgs} args - Arguments to find a CalculationParameter
     * @example
     * // Get one CalculationParameter
     * const calculationParameter = await prisma.calculationParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalculationParameterFindUniqueArgs>(args: SelectSubset<T, CalculationParameterFindUniqueArgs<ExtArgs>>): Prisma__CalculationParameterClient<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalculationParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalculationParameterFindUniqueOrThrowArgs} args - Arguments to find a CalculationParameter
     * @example
     * // Get one CalculationParameter
     * const calculationParameter = await prisma.calculationParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalculationParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, CalculationParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalculationParameterClient<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalculationParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationParameterFindFirstArgs} args - Arguments to find a CalculationParameter
     * @example
     * // Get one CalculationParameter
     * const calculationParameter = await prisma.calculationParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalculationParameterFindFirstArgs>(args?: SelectSubset<T, CalculationParameterFindFirstArgs<ExtArgs>>): Prisma__CalculationParameterClient<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalculationParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationParameterFindFirstOrThrowArgs} args - Arguments to find a CalculationParameter
     * @example
     * // Get one CalculationParameter
     * const calculationParameter = await prisma.calculationParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalculationParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, CalculationParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalculationParameterClient<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalculationParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalculationParameters
     * const calculationParameters = await prisma.calculationParameter.findMany()
     * 
     * // Get first 10 CalculationParameters
     * const calculationParameters = await prisma.calculationParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calculationParameterWithIdOnly = await prisma.calculationParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalculationParameterFindManyArgs>(args?: SelectSubset<T, CalculationParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalculationParameter.
     * @param {CalculationParameterCreateArgs} args - Arguments to create a CalculationParameter.
     * @example
     * // Create one CalculationParameter
     * const CalculationParameter = await prisma.calculationParameter.create({
     *   data: {
     *     // ... data to create a CalculationParameter
     *   }
     * })
     * 
     */
    create<T extends CalculationParameterCreateArgs>(args: SelectSubset<T, CalculationParameterCreateArgs<ExtArgs>>): Prisma__CalculationParameterClient<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalculationParameters.
     * @param {CalculationParameterCreateManyArgs} args - Arguments to create many CalculationParameters.
     * @example
     * // Create many CalculationParameters
     * const calculationParameter = await prisma.calculationParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalculationParameterCreateManyArgs>(args?: SelectSubset<T, CalculationParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CalculationParameter.
     * @param {CalculationParameterDeleteArgs} args - Arguments to delete one CalculationParameter.
     * @example
     * // Delete one CalculationParameter
     * const CalculationParameter = await prisma.calculationParameter.delete({
     *   where: {
     *     // ... filter to delete one CalculationParameter
     *   }
     * })
     * 
     */
    delete<T extends CalculationParameterDeleteArgs>(args: SelectSubset<T, CalculationParameterDeleteArgs<ExtArgs>>): Prisma__CalculationParameterClient<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalculationParameter.
     * @param {CalculationParameterUpdateArgs} args - Arguments to update one CalculationParameter.
     * @example
     * // Update one CalculationParameter
     * const calculationParameter = await prisma.calculationParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalculationParameterUpdateArgs>(args: SelectSubset<T, CalculationParameterUpdateArgs<ExtArgs>>): Prisma__CalculationParameterClient<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalculationParameters.
     * @param {CalculationParameterDeleteManyArgs} args - Arguments to filter CalculationParameters to delete.
     * @example
     * // Delete a few CalculationParameters
     * const { count } = await prisma.calculationParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalculationParameterDeleteManyArgs>(args?: SelectSubset<T, CalculationParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalculationParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalculationParameters
     * const calculationParameter = await prisma.calculationParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalculationParameterUpdateManyArgs>(args: SelectSubset<T, CalculationParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalculationParameter.
     * @param {CalculationParameterUpsertArgs} args - Arguments to update or create a CalculationParameter.
     * @example
     * // Update or create a CalculationParameter
     * const calculationParameter = await prisma.calculationParameter.upsert({
     *   create: {
     *     // ... data to create a CalculationParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalculationParameter we want to update
     *   }
     * })
     */
    upsert<T extends CalculationParameterUpsertArgs>(args: SelectSubset<T, CalculationParameterUpsertArgs<ExtArgs>>): Prisma__CalculationParameterClient<$Result.GetResult<Prisma.$CalculationParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalculationParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationParameterCountArgs} args - Arguments to filter CalculationParameters to count.
     * @example
     * // Count the number of CalculationParameters
     * const count = await prisma.calculationParameter.count({
     *   where: {
     *     // ... the filter for the CalculationParameters we want to count
     *   }
     * })
    **/
    count<T extends CalculationParameterCountArgs>(
      args?: Subset<T, CalculationParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalculationParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalculationParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalculationParameterAggregateArgs>(args: Subset<T, CalculationParameterAggregateArgs>): Prisma.PrismaPromise<GetCalculationParameterAggregateType<T>>

    /**
     * Group by CalculationParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalculationParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalculationParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalculationParameterGroupByArgs['orderBy'] }
        : { orderBy?: CalculationParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalculationParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalculationParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalculationParameter model
   */
  readonly fields: CalculationParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalculationParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalculationParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calculationType<T extends CalculationTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalculationTypeDefaultArgs<ExtArgs>>): Prisma__CalculationTypeClient<$Result.GetResult<Prisma.$CalculationTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    canton<T extends CalculationParameter$cantonArgs<ExtArgs> = {}>(args?: Subset<T, CalculationParameter$cantonArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalculationParameter model
   */
  interface CalculationParameterFieldRefs {
    readonly id: FieldRef<"CalculationParameter", 'Int'>
    readonly calculationTypeId: FieldRef<"CalculationParameter", 'Int'>
    readonly cantonId: FieldRef<"CalculationParameter", 'Int'>
    readonly parameterKey: FieldRef<"CalculationParameter", 'String'>
    readonly parameterValue: FieldRef<"CalculationParameter", 'String'>
    readonly valueType: FieldRef<"CalculationParameter", 'ValueType'>
    readonly unit: FieldRef<"CalculationParameter", 'String'>
    readonly description: FieldRef<"CalculationParameter", 'String'>
    readonly createdAt: FieldRef<"CalculationParameter", 'DateTime'>
    readonly updatedAt: FieldRef<"CalculationParameter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalculationParameter findUnique
   */
  export type CalculationParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    /**
     * Filter, which CalculationParameter to fetch.
     */
    where: CalculationParameterWhereUniqueInput
  }

  /**
   * CalculationParameter findUniqueOrThrow
   */
  export type CalculationParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    /**
     * Filter, which CalculationParameter to fetch.
     */
    where: CalculationParameterWhereUniqueInput
  }

  /**
   * CalculationParameter findFirst
   */
  export type CalculationParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    /**
     * Filter, which CalculationParameter to fetch.
     */
    where?: CalculationParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationParameters to fetch.
     */
    orderBy?: CalculationParameterOrderByWithRelationInput | CalculationParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalculationParameters.
     */
    cursor?: CalculationParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalculationParameters.
     */
    distinct?: CalculationParameterScalarFieldEnum | CalculationParameterScalarFieldEnum[]
  }

  /**
   * CalculationParameter findFirstOrThrow
   */
  export type CalculationParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    /**
     * Filter, which CalculationParameter to fetch.
     */
    where?: CalculationParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationParameters to fetch.
     */
    orderBy?: CalculationParameterOrderByWithRelationInput | CalculationParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalculationParameters.
     */
    cursor?: CalculationParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalculationParameters.
     */
    distinct?: CalculationParameterScalarFieldEnum | CalculationParameterScalarFieldEnum[]
  }

  /**
   * CalculationParameter findMany
   */
  export type CalculationParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    /**
     * Filter, which CalculationParameters to fetch.
     */
    where?: CalculationParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalculationParameters to fetch.
     */
    orderBy?: CalculationParameterOrderByWithRelationInput | CalculationParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalculationParameters.
     */
    cursor?: CalculationParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalculationParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalculationParameters.
     */
    skip?: number
    distinct?: CalculationParameterScalarFieldEnum | CalculationParameterScalarFieldEnum[]
  }

  /**
   * CalculationParameter create
   */
  export type CalculationParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    /**
     * The data needed to create a CalculationParameter.
     */
    data: XOR<CalculationParameterCreateInput, CalculationParameterUncheckedCreateInput>
  }

  /**
   * CalculationParameter createMany
   */
  export type CalculationParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalculationParameters.
     */
    data: CalculationParameterCreateManyInput | CalculationParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalculationParameter update
   */
  export type CalculationParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    /**
     * The data needed to update a CalculationParameter.
     */
    data: XOR<CalculationParameterUpdateInput, CalculationParameterUncheckedUpdateInput>
    /**
     * Choose, which CalculationParameter to update.
     */
    where: CalculationParameterWhereUniqueInput
  }

  /**
   * CalculationParameter updateMany
   */
  export type CalculationParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalculationParameters.
     */
    data: XOR<CalculationParameterUpdateManyMutationInput, CalculationParameterUncheckedUpdateManyInput>
    /**
     * Filter which CalculationParameters to update
     */
    where?: CalculationParameterWhereInput
    /**
     * Limit how many CalculationParameters to update.
     */
    limit?: number
  }

  /**
   * CalculationParameter upsert
   */
  export type CalculationParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    /**
     * The filter to search for the CalculationParameter to update in case it exists.
     */
    where: CalculationParameterWhereUniqueInput
    /**
     * In case the CalculationParameter found by the `where` argument doesn't exist, create a new CalculationParameter with this data.
     */
    create: XOR<CalculationParameterCreateInput, CalculationParameterUncheckedCreateInput>
    /**
     * In case the CalculationParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalculationParameterUpdateInput, CalculationParameterUncheckedUpdateInput>
  }

  /**
   * CalculationParameter delete
   */
  export type CalculationParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
    /**
     * Filter which CalculationParameter to delete.
     */
    where: CalculationParameterWhereUniqueInput
  }

  /**
   * CalculationParameter deleteMany
   */
  export type CalculationParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalculationParameters to delete
     */
    where?: CalculationParameterWhereInput
    /**
     * Limit how many CalculationParameters to delete.
     */
    limit?: number
  }

  /**
   * CalculationParameter.canton
   */
  export type CalculationParameter$cantonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    where?: CantonWhereInput
  }

  /**
   * CalculationParameter without action
   */
  export type CalculationParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalculationParameter
     */
    select?: CalculationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalculationParameter
     */
    omit?: CalculationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalculationParameterInclude<ExtArgs> | null
  }


  /**
   * Model ExampleCategory
   */

  export type AggregateExampleCategory = {
    _count: ExampleCategoryCountAggregateOutputType | null
    _avg: ExampleCategoryAvgAggregateOutputType | null
    _sum: ExampleCategorySumAggregateOutputType | null
    _min: ExampleCategoryMinAggregateOutputType | null
    _max: ExampleCategoryMaxAggregateOutputType | null
  }

  export type ExampleCategoryAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type ExampleCategorySumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type ExampleCategoryMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    icon: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExampleCategoryMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    icon: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExampleCategoryCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    icon: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExampleCategoryAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type ExampleCategorySumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type ExampleCategoryMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    icon?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExampleCategoryMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    icon?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExampleCategoryCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    icon?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExampleCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExampleCategory to aggregate.
     */
    where?: ExampleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExampleCategories to fetch.
     */
    orderBy?: ExampleCategoryOrderByWithRelationInput | ExampleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExampleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExampleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExampleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExampleCategories
    **/
    _count?: true | ExampleCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExampleCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExampleCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExampleCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExampleCategoryMaxAggregateInputType
  }

  export type GetExampleCategoryAggregateType<T extends ExampleCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExampleCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExampleCategory[P]>
      : GetScalarType<T[P], AggregateExampleCategory[P]>
  }




  export type ExampleCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExampleCategoryWhereInput
    orderBy?: ExampleCategoryOrderByWithAggregationInput | ExampleCategoryOrderByWithAggregationInput[]
    by: ExampleCategoryScalarFieldEnum[] | ExampleCategoryScalarFieldEnum
    having?: ExampleCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExampleCategoryCountAggregateInputType | true
    _avg?: ExampleCategoryAvgAggregateInputType
    _sum?: ExampleCategorySumAggregateInputType
    _min?: ExampleCategoryMinAggregateInputType
    _max?: ExampleCategoryMaxAggregateInputType
  }

  export type ExampleCategoryGroupByOutputType = {
    id: number
    slug: string
    name: string
    icon: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ExampleCategoryCountAggregateOutputType | null
    _avg: ExampleCategoryAvgAggregateOutputType | null
    _sum: ExampleCategorySumAggregateOutputType | null
    _min: ExampleCategoryMinAggregateOutputType | null
    _max: ExampleCategoryMaxAggregateOutputType | null
  }

  type GetExampleCategoryGroupByPayload<T extends ExampleCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExampleCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExampleCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExampleCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExampleCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExampleCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    icon?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examples?: boolean | ExampleCategory$examplesArgs<ExtArgs>
    _count?: boolean | ExampleCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exampleCategory"]>



  export type ExampleCategorySelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    icon?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExampleCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "icon" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["exampleCategory"]>
  export type ExampleCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examples?: boolean | ExampleCategory$examplesArgs<ExtArgs>
    _count?: boolean | ExampleCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ExampleCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExampleCategory"
    objects: {
      examples: Prisma.$ExamplePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      name: string
      icon: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exampleCategory"]>
    composites: {}
  }

  type ExampleCategoryGetPayload<S extends boolean | null | undefined | ExampleCategoryDefaultArgs> = $Result.GetResult<Prisma.$ExampleCategoryPayload, S>

  type ExampleCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExampleCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExampleCategoryCountAggregateInputType | true
    }

  export interface ExampleCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExampleCategory'], meta: { name: 'ExampleCategory' } }
    /**
     * Find zero or one ExampleCategory that matches the filter.
     * @param {ExampleCategoryFindUniqueArgs} args - Arguments to find a ExampleCategory
     * @example
     * // Get one ExampleCategory
     * const exampleCategory = await prisma.exampleCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExampleCategoryFindUniqueArgs>(args: SelectSubset<T, ExampleCategoryFindUniqueArgs<ExtArgs>>): Prisma__ExampleCategoryClient<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExampleCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExampleCategoryFindUniqueOrThrowArgs} args - Arguments to find a ExampleCategory
     * @example
     * // Get one ExampleCategory
     * const exampleCategory = await prisma.exampleCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExampleCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExampleCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExampleCategoryClient<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExampleCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleCategoryFindFirstArgs} args - Arguments to find a ExampleCategory
     * @example
     * // Get one ExampleCategory
     * const exampleCategory = await prisma.exampleCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExampleCategoryFindFirstArgs>(args?: SelectSubset<T, ExampleCategoryFindFirstArgs<ExtArgs>>): Prisma__ExampleCategoryClient<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExampleCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleCategoryFindFirstOrThrowArgs} args - Arguments to find a ExampleCategory
     * @example
     * // Get one ExampleCategory
     * const exampleCategory = await prisma.exampleCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExampleCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExampleCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExampleCategoryClient<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExampleCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExampleCategories
     * const exampleCategories = await prisma.exampleCategory.findMany()
     * 
     * // Get first 10 ExampleCategories
     * const exampleCategories = await prisma.exampleCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exampleCategoryWithIdOnly = await prisma.exampleCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExampleCategoryFindManyArgs>(args?: SelectSubset<T, ExampleCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExampleCategory.
     * @param {ExampleCategoryCreateArgs} args - Arguments to create a ExampleCategory.
     * @example
     * // Create one ExampleCategory
     * const ExampleCategory = await prisma.exampleCategory.create({
     *   data: {
     *     // ... data to create a ExampleCategory
     *   }
     * })
     * 
     */
    create<T extends ExampleCategoryCreateArgs>(args: SelectSubset<T, ExampleCategoryCreateArgs<ExtArgs>>): Prisma__ExampleCategoryClient<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExampleCategories.
     * @param {ExampleCategoryCreateManyArgs} args - Arguments to create many ExampleCategories.
     * @example
     * // Create many ExampleCategories
     * const exampleCategory = await prisma.exampleCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExampleCategoryCreateManyArgs>(args?: SelectSubset<T, ExampleCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExampleCategory.
     * @param {ExampleCategoryDeleteArgs} args - Arguments to delete one ExampleCategory.
     * @example
     * // Delete one ExampleCategory
     * const ExampleCategory = await prisma.exampleCategory.delete({
     *   where: {
     *     // ... filter to delete one ExampleCategory
     *   }
     * })
     * 
     */
    delete<T extends ExampleCategoryDeleteArgs>(args: SelectSubset<T, ExampleCategoryDeleteArgs<ExtArgs>>): Prisma__ExampleCategoryClient<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExampleCategory.
     * @param {ExampleCategoryUpdateArgs} args - Arguments to update one ExampleCategory.
     * @example
     * // Update one ExampleCategory
     * const exampleCategory = await prisma.exampleCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExampleCategoryUpdateArgs>(args: SelectSubset<T, ExampleCategoryUpdateArgs<ExtArgs>>): Prisma__ExampleCategoryClient<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExampleCategories.
     * @param {ExampleCategoryDeleteManyArgs} args - Arguments to filter ExampleCategories to delete.
     * @example
     * // Delete a few ExampleCategories
     * const { count } = await prisma.exampleCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExampleCategoryDeleteManyArgs>(args?: SelectSubset<T, ExampleCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExampleCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExampleCategories
     * const exampleCategory = await prisma.exampleCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExampleCategoryUpdateManyArgs>(args: SelectSubset<T, ExampleCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExampleCategory.
     * @param {ExampleCategoryUpsertArgs} args - Arguments to update or create a ExampleCategory.
     * @example
     * // Update or create a ExampleCategory
     * const exampleCategory = await prisma.exampleCategory.upsert({
     *   create: {
     *     // ... data to create a ExampleCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExampleCategory we want to update
     *   }
     * })
     */
    upsert<T extends ExampleCategoryUpsertArgs>(args: SelectSubset<T, ExampleCategoryUpsertArgs<ExtArgs>>): Prisma__ExampleCategoryClient<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExampleCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleCategoryCountArgs} args - Arguments to filter ExampleCategories to count.
     * @example
     * // Count the number of ExampleCategories
     * const count = await prisma.exampleCategory.count({
     *   where: {
     *     // ... the filter for the ExampleCategories we want to count
     *   }
     * })
    **/
    count<T extends ExampleCategoryCountArgs>(
      args?: Subset<T, ExampleCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExampleCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExampleCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExampleCategoryAggregateArgs>(args: Subset<T, ExampleCategoryAggregateArgs>): Prisma.PrismaPromise<GetExampleCategoryAggregateType<T>>

    /**
     * Group by ExampleCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExampleCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExampleCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExampleCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExampleCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExampleCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExampleCategory model
   */
  readonly fields: ExampleCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExampleCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExampleCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examples<T extends ExampleCategory$examplesArgs<ExtArgs> = {}>(args?: Subset<T, ExampleCategory$examplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExampleCategory model
   */
  interface ExampleCategoryFieldRefs {
    readonly id: FieldRef<"ExampleCategory", 'Int'>
    readonly slug: FieldRef<"ExampleCategory", 'String'>
    readonly name: FieldRef<"ExampleCategory", 'String'>
    readonly icon: FieldRef<"ExampleCategory", 'String'>
    readonly sortOrder: FieldRef<"ExampleCategory", 'Int'>
    readonly createdAt: FieldRef<"ExampleCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ExampleCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExampleCategory findUnique
   */
  export type ExampleCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExampleCategory to fetch.
     */
    where: ExampleCategoryWhereUniqueInput
  }

  /**
   * ExampleCategory findUniqueOrThrow
   */
  export type ExampleCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExampleCategory to fetch.
     */
    where: ExampleCategoryWhereUniqueInput
  }

  /**
   * ExampleCategory findFirst
   */
  export type ExampleCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExampleCategory to fetch.
     */
    where?: ExampleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExampleCategories to fetch.
     */
    orderBy?: ExampleCategoryOrderByWithRelationInput | ExampleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExampleCategories.
     */
    cursor?: ExampleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExampleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExampleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExampleCategories.
     */
    distinct?: ExampleCategoryScalarFieldEnum | ExampleCategoryScalarFieldEnum[]
  }

  /**
   * ExampleCategory findFirstOrThrow
   */
  export type ExampleCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExampleCategory to fetch.
     */
    where?: ExampleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExampleCategories to fetch.
     */
    orderBy?: ExampleCategoryOrderByWithRelationInput | ExampleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExampleCategories.
     */
    cursor?: ExampleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExampleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExampleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExampleCategories.
     */
    distinct?: ExampleCategoryScalarFieldEnum | ExampleCategoryScalarFieldEnum[]
  }

  /**
   * ExampleCategory findMany
   */
  export type ExampleCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExampleCategories to fetch.
     */
    where?: ExampleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExampleCategories to fetch.
     */
    orderBy?: ExampleCategoryOrderByWithRelationInput | ExampleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExampleCategories.
     */
    cursor?: ExampleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExampleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExampleCategories.
     */
    skip?: number
    distinct?: ExampleCategoryScalarFieldEnum | ExampleCategoryScalarFieldEnum[]
  }

  /**
   * ExampleCategory create
   */
  export type ExampleCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExampleCategory.
     */
    data: XOR<ExampleCategoryCreateInput, ExampleCategoryUncheckedCreateInput>
  }

  /**
   * ExampleCategory createMany
   */
  export type ExampleCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExampleCategories.
     */
    data: ExampleCategoryCreateManyInput | ExampleCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExampleCategory update
   */
  export type ExampleCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExampleCategory.
     */
    data: XOR<ExampleCategoryUpdateInput, ExampleCategoryUncheckedUpdateInput>
    /**
     * Choose, which ExampleCategory to update.
     */
    where: ExampleCategoryWhereUniqueInput
  }

  /**
   * ExampleCategory updateMany
   */
  export type ExampleCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExampleCategories.
     */
    data: XOR<ExampleCategoryUpdateManyMutationInput, ExampleCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExampleCategories to update
     */
    where?: ExampleCategoryWhereInput
    /**
     * Limit how many ExampleCategories to update.
     */
    limit?: number
  }

  /**
   * ExampleCategory upsert
   */
  export type ExampleCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExampleCategory to update in case it exists.
     */
    where: ExampleCategoryWhereUniqueInput
    /**
     * In case the ExampleCategory found by the `where` argument doesn't exist, create a new ExampleCategory with this data.
     */
    create: XOR<ExampleCategoryCreateInput, ExampleCategoryUncheckedCreateInput>
    /**
     * In case the ExampleCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExampleCategoryUpdateInput, ExampleCategoryUncheckedUpdateInput>
  }

  /**
   * ExampleCategory delete
   */
  export type ExampleCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
    /**
     * Filter which ExampleCategory to delete.
     */
    where: ExampleCategoryWhereUniqueInput
  }

  /**
   * ExampleCategory deleteMany
   */
  export type ExampleCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExampleCategories to delete
     */
    where?: ExampleCategoryWhereInput
    /**
     * Limit how many ExampleCategories to delete.
     */
    limit?: number
  }

  /**
   * ExampleCategory.examples
   */
  export type ExampleCategory$examplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    where?: ExampleWhereInput
    orderBy?: ExampleOrderByWithRelationInput | ExampleOrderByWithRelationInput[]
    cursor?: ExampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExampleScalarFieldEnum | ExampleScalarFieldEnum[]
  }

  /**
   * ExampleCategory without action
   */
  export type ExampleCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExampleCategory
     */
    select?: ExampleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExampleCategory
     */
    omit?: ExampleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Example
   */

  export type AggregateExample = {
    _count: ExampleCountAggregateOutputType | null
    _avg: ExampleAvgAggregateOutputType | null
    _sum: ExampleSumAggregateOutputType | null
    _min: ExampleMinAggregateOutputType | null
    _max: ExampleMaxAggregateOutputType | null
  }

  export type ExampleAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    cantonId: number | null
    capacity: number | null
    sortOrder: number | null
  }

  export type ExampleSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    cantonId: number | null
    capacity: number | null
    sortOrder: number | null
  }

  export type ExampleMinAggregateOutputType = {
    id: number | null
    categoryId: number | null
    cantonId: number | null
    title: string | null
    description: string | null
    content: string | null
    eventType: string | null
    capacity: number | null
    imageUrl: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExampleMaxAggregateOutputType = {
    id: number | null
    categoryId: number | null
    cantonId: number | null
    title: string | null
    description: string | null
    content: string | null
    eventType: string | null
    capacity: number | null
    imageUrl: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExampleCountAggregateOutputType = {
    id: number
    categoryId: number
    cantonId: number
    title: number
    description: number
    content: number
    eventType: number
    capacity: number
    imageUrl: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExampleAvgAggregateInputType = {
    id?: true
    categoryId?: true
    cantonId?: true
    capacity?: true
    sortOrder?: true
  }

  export type ExampleSumAggregateInputType = {
    id?: true
    categoryId?: true
    cantonId?: true
    capacity?: true
    sortOrder?: true
  }

  export type ExampleMinAggregateInputType = {
    id?: true
    categoryId?: true
    cantonId?: true
    title?: true
    description?: true
    content?: true
    eventType?: true
    capacity?: true
    imageUrl?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExampleMaxAggregateInputType = {
    id?: true
    categoryId?: true
    cantonId?: true
    title?: true
    description?: true
    content?: true
    eventType?: true
    capacity?: true
    imageUrl?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExampleCountAggregateInputType = {
    id?: true
    categoryId?: true
    cantonId?: true
    title?: true
    description?: true
    content?: true
    eventType?: true
    capacity?: true
    imageUrl?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Example to aggregate.
     */
    where?: ExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examples to fetch.
     */
    orderBy?: ExampleOrderByWithRelationInput | ExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Examples
    **/
    _count?: true | ExampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExampleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExampleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExampleMaxAggregateInputType
  }

  export type GetExampleAggregateType<T extends ExampleAggregateArgs> = {
        [P in keyof T & keyof AggregateExample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExample[P]>
      : GetScalarType<T[P], AggregateExample[P]>
  }




  export type ExampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExampleWhereInput
    orderBy?: ExampleOrderByWithAggregationInput | ExampleOrderByWithAggregationInput[]
    by: ExampleScalarFieldEnum[] | ExampleScalarFieldEnum
    having?: ExampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExampleCountAggregateInputType | true
    _avg?: ExampleAvgAggregateInputType
    _sum?: ExampleSumAggregateInputType
    _min?: ExampleMinAggregateInputType
    _max?: ExampleMaxAggregateInputType
  }

  export type ExampleGroupByOutputType = {
    id: number
    categoryId: number
    cantonId: number | null
    title: string
    description: string
    content: string
    eventType: string | null
    capacity: number | null
    imageUrl: string | null
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ExampleCountAggregateOutputType | null
    _avg: ExampleAvgAggregateOutputType | null
    _sum: ExampleSumAggregateOutputType | null
    _min: ExampleMinAggregateOutputType | null
    _max: ExampleMaxAggregateOutputType | null
  }

  type GetExampleGroupByPayload<T extends ExampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExampleGroupByOutputType[P]>
            : GetScalarType<T[P], ExampleGroupByOutputType[P]>
        }
      >
    >


  export type ExampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    cantonId?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    eventType?: boolean
    capacity?: boolean
    imageUrl?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | ExampleCategoryDefaultArgs<ExtArgs>
    canton?: boolean | Example$cantonArgs<ExtArgs>
  }, ExtArgs["result"]["example"]>



  export type ExampleSelectScalar = {
    id?: boolean
    categoryId?: boolean
    cantonId?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    eventType?: boolean
    capacity?: boolean
    imageUrl?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "categoryId" | "cantonId" | "title" | "description" | "content" | "eventType" | "capacity" | "imageUrl" | "isActive" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["example"]>
  export type ExampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ExampleCategoryDefaultArgs<ExtArgs>
    canton?: boolean | Example$cantonArgs<ExtArgs>
  }

  export type $ExamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Example"
    objects: {
      category: Prisma.$ExampleCategoryPayload<ExtArgs>
      canton: Prisma.$CantonPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      categoryId: number
      cantonId: number | null
      title: string
      description: string
      content: string
      eventType: string | null
      capacity: number | null
      imageUrl: string | null
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["example"]>
    composites: {}
  }

  type ExampleGetPayload<S extends boolean | null | undefined | ExampleDefaultArgs> = $Result.GetResult<Prisma.$ExamplePayload, S>

  type ExampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExampleCountAggregateInputType | true
    }

  export interface ExampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Example'], meta: { name: 'Example' } }
    /**
     * Find zero or one Example that matches the filter.
     * @param {ExampleFindUniqueArgs} args - Arguments to find a Example
     * @example
     * // Get one Example
     * const example = await prisma.example.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExampleFindUniqueArgs>(args: SelectSubset<T, ExampleFindUniqueArgs<ExtArgs>>): Prisma__ExampleClient<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Example that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExampleFindUniqueOrThrowArgs} args - Arguments to find a Example
     * @example
     * // Get one Example
     * const example = await prisma.example.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExampleFindUniqueOrThrowArgs>(args: SelectSubset<T, ExampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExampleClient<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Example that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleFindFirstArgs} args - Arguments to find a Example
     * @example
     * // Get one Example
     * const example = await prisma.example.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExampleFindFirstArgs>(args?: SelectSubset<T, ExampleFindFirstArgs<ExtArgs>>): Prisma__ExampleClient<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Example that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleFindFirstOrThrowArgs} args - Arguments to find a Example
     * @example
     * // Get one Example
     * const example = await prisma.example.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExampleFindFirstOrThrowArgs>(args?: SelectSubset<T, ExampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExampleClient<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Examples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Examples
     * const examples = await prisma.example.findMany()
     * 
     * // Get first 10 Examples
     * const examples = await prisma.example.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exampleWithIdOnly = await prisma.example.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExampleFindManyArgs>(args?: SelectSubset<T, ExampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Example.
     * @param {ExampleCreateArgs} args - Arguments to create a Example.
     * @example
     * // Create one Example
     * const Example = await prisma.example.create({
     *   data: {
     *     // ... data to create a Example
     *   }
     * })
     * 
     */
    create<T extends ExampleCreateArgs>(args: SelectSubset<T, ExampleCreateArgs<ExtArgs>>): Prisma__ExampleClient<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Examples.
     * @param {ExampleCreateManyArgs} args - Arguments to create many Examples.
     * @example
     * // Create many Examples
     * const example = await prisma.example.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExampleCreateManyArgs>(args?: SelectSubset<T, ExampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Example.
     * @param {ExampleDeleteArgs} args - Arguments to delete one Example.
     * @example
     * // Delete one Example
     * const Example = await prisma.example.delete({
     *   where: {
     *     // ... filter to delete one Example
     *   }
     * })
     * 
     */
    delete<T extends ExampleDeleteArgs>(args: SelectSubset<T, ExampleDeleteArgs<ExtArgs>>): Prisma__ExampleClient<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Example.
     * @param {ExampleUpdateArgs} args - Arguments to update one Example.
     * @example
     * // Update one Example
     * const example = await prisma.example.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExampleUpdateArgs>(args: SelectSubset<T, ExampleUpdateArgs<ExtArgs>>): Prisma__ExampleClient<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Examples.
     * @param {ExampleDeleteManyArgs} args - Arguments to filter Examples to delete.
     * @example
     * // Delete a few Examples
     * const { count } = await prisma.example.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExampleDeleteManyArgs>(args?: SelectSubset<T, ExampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Examples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Examples
     * const example = await prisma.example.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExampleUpdateManyArgs>(args: SelectSubset<T, ExampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Example.
     * @param {ExampleUpsertArgs} args - Arguments to update or create a Example.
     * @example
     * // Update or create a Example
     * const example = await prisma.example.upsert({
     *   create: {
     *     // ... data to create a Example
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Example we want to update
     *   }
     * })
     */
    upsert<T extends ExampleUpsertArgs>(args: SelectSubset<T, ExampleUpsertArgs<ExtArgs>>): Prisma__ExampleClient<$Result.GetResult<Prisma.$ExamplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Examples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleCountArgs} args - Arguments to filter Examples to count.
     * @example
     * // Count the number of Examples
     * const count = await prisma.example.count({
     *   where: {
     *     // ... the filter for the Examples we want to count
     *   }
     * })
    **/
    count<T extends ExampleCountArgs>(
      args?: Subset<T, ExampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Example.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExampleAggregateArgs>(args: Subset<T, ExampleAggregateArgs>): Prisma.PrismaPromise<GetExampleAggregateType<T>>

    /**
     * Group by Example.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExampleGroupByArgs['orderBy'] }
        : { orderBy?: ExampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Example model
   */
  readonly fields: ExampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Example.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends ExampleCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExampleCategoryDefaultArgs<ExtArgs>>): Prisma__ExampleCategoryClient<$Result.GetResult<Prisma.$ExampleCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    canton<T extends Example$cantonArgs<ExtArgs> = {}>(args?: Subset<T, Example$cantonArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Example model
   */
  interface ExampleFieldRefs {
    readonly id: FieldRef<"Example", 'Int'>
    readonly categoryId: FieldRef<"Example", 'Int'>
    readonly cantonId: FieldRef<"Example", 'Int'>
    readonly title: FieldRef<"Example", 'String'>
    readonly description: FieldRef<"Example", 'String'>
    readonly content: FieldRef<"Example", 'String'>
    readonly eventType: FieldRef<"Example", 'String'>
    readonly capacity: FieldRef<"Example", 'Int'>
    readonly imageUrl: FieldRef<"Example", 'String'>
    readonly isActive: FieldRef<"Example", 'Boolean'>
    readonly sortOrder: FieldRef<"Example", 'Int'>
    readonly createdAt: FieldRef<"Example", 'DateTime'>
    readonly updatedAt: FieldRef<"Example", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Example findUnique
   */
  export type ExampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    /**
     * Filter, which Example to fetch.
     */
    where: ExampleWhereUniqueInput
  }

  /**
   * Example findUniqueOrThrow
   */
  export type ExampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    /**
     * Filter, which Example to fetch.
     */
    where: ExampleWhereUniqueInput
  }

  /**
   * Example findFirst
   */
  export type ExampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    /**
     * Filter, which Example to fetch.
     */
    where?: ExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examples to fetch.
     */
    orderBy?: ExampleOrderByWithRelationInput | ExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examples.
     */
    cursor?: ExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examples.
     */
    distinct?: ExampleScalarFieldEnum | ExampleScalarFieldEnum[]
  }

  /**
   * Example findFirstOrThrow
   */
  export type ExampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    /**
     * Filter, which Example to fetch.
     */
    where?: ExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examples to fetch.
     */
    orderBy?: ExampleOrderByWithRelationInput | ExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Examples.
     */
    cursor?: ExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Examples.
     */
    distinct?: ExampleScalarFieldEnum | ExampleScalarFieldEnum[]
  }

  /**
   * Example findMany
   */
  export type ExampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    /**
     * Filter, which Examples to fetch.
     */
    where?: ExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Examples to fetch.
     */
    orderBy?: ExampleOrderByWithRelationInput | ExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Examples.
     */
    cursor?: ExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Examples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Examples.
     */
    skip?: number
    distinct?: ExampleScalarFieldEnum | ExampleScalarFieldEnum[]
  }

  /**
   * Example create
   */
  export type ExampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    /**
     * The data needed to create a Example.
     */
    data: XOR<ExampleCreateInput, ExampleUncheckedCreateInput>
  }

  /**
   * Example createMany
   */
  export type ExampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Examples.
     */
    data: ExampleCreateManyInput | ExampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Example update
   */
  export type ExampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    /**
     * The data needed to update a Example.
     */
    data: XOR<ExampleUpdateInput, ExampleUncheckedUpdateInput>
    /**
     * Choose, which Example to update.
     */
    where: ExampleWhereUniqueInput
  }

  /**
   * Example updateMany
   */
  export type ExampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Examples.
     */
    data: XOR<ExampleUpdateManyMutationInput, ExampleUncheckedUpdateManyInput>
    /**
     * Filter which Examples to update
     */
    where?: ExampleWhereInput
    /**
     * Limit how many Examples to update.
     */
    limit?: number
  }

  /**
   * Example upsert
   */
  export type ExampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    /**
     * The filter to search for the Example to update in case it exists.
     */
    where: ExampleWhereUniqueInput
    /**
     * In case the Example found by the `where` argument doesn't exist, create a new Example with this data.
     */
    create: XOR<ExampleCreateInput, ExampleUncheckedCreateInput>
    /**
     * In case the Example was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExampleUpdateInput, ExampleUncheckedUpdateInput>
  }

  /**
   * Example delete
   */
  export type ExampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
    /**
     * Filter which Example to delete.
     */
    where: ExampleWhereUniqueInput
  }

  /**
   * Example deleteMany
   */
  export type ExampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Examples to delete
     */
    where?: ExampleWhereInput
    /**
     * Limit how many Examples to delete.
     */
    limit?: number
  }

  /**
   * Example.canton
   */
  export type Example$cantonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    where?: CantonWhereInput
  }

  /**
   * Example without action
   */
  export type ExampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Example
     */
    select?: ExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Example
     */
    omit?: ExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExampleInclude<ExtArgs> | null
  }


  /**
   * Model ContactType
   */

  export type AggregateContactType = {
    _count: ContactTypeCountAggregateOutputType | null
    _avg: ContactTypeAvgAggregateOutputType | null
    _sum: ContactTypeSumAggregateOutputType | null
    _min: ContactTypeMinAggregateOutputType | null
    _max: ContactTypeMaxAggregateOutputType | null
  }

  export type ContactTypeAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type ContactTypeSumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type ContactTypeMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactTypeMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactTypeCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactTypeAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type ContactTypeSumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type ContactTypeMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactTypeMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactTypeCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactType to aggregate.
     */
    where?: ContactTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTypes to fetch.
     */
    orderBy?: ContactTypeOrderByWithRelationInput | ContactTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactTypes
    **/
    _count?: true | ContactTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactTypeMaxAggregateInputType
  }

  export type GetContactTypeAggregateType<T extends ContactTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContactType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactType[P]>
      : GetScalarType<T[P], AggregateContactType[P]>
  }




  export type ContactTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTypeWhereInput
    orderBy?: ContactTypeOrderByWithAggregationInput | ContactTypeOrderByWithAggregationInput[]
    by: ContactTypeScalarFieldEnum[] | ContactTypeScalarFieldEnum
    having?: ContactTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactTypeCountAggregateInputType | true
    _avg?: ContactTypeAvgAggregateInputType
    _sum?: ContactTypeSumAggregateInputType
    _min?: ContactTypeMinAggregateInputType
    _max?: ContactTypeMaxAggregateInputType
  }

  export type ContactTypeGroupByOutputType = {
    id: number
    slug: string
    name: string
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ContactTypeCountAggregateOutputType | null
    _avg: ContactTypeAvgAggregateOutputType | null
    _sum: ContactTypeSumAggregateOutputType | null
    _min: ContactTypeMinAggregateOutputType | null
    _max: ContactTypeMaxAggregateOutputType | null
  }

  type GetContactTypeGroupByPayload<T extends ContactTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContactTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContactTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contacts?: boolean | ContactType$contactsArgs<ExtArgs>
    _count?: boolean | ContactTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactType"]>



  export type ContactTypeSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["contactType"]>
  export type ContactTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | ContactType$contactsArgs<ExtArgs>
    _count?: boolean | ContactTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContactTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactType"
    objects: {
      contacts: Prisma.$ContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      name: string
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactType"]>
    composites: {}
  }

  type ContactTypeGetPayload<S extends boolean | null | undefined | ContactTypeDefaultArgs> = $Result.GetResult<Prisma.$ContactTypePayload, S>

  type ContactTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactTypeCountAggregateInputType | true
    }

  export interface ContactTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactType'], meta: { name: 'ContactType' } }
    /**
     * Find zero or one ContactType that matches the filter.
     * @param {ContactTypeFindUniqueArgs} args - Arguments to find a ContactType
     * @example
     * // Get one ContactType
     * const contactType = await prisma.contactType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactTypeFindUniqueArgs>(args: SelectSubset<T, ContactTypeFindUniqueArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactTypeFindUniqueOrThrowArgs} args - Arguments to find a ContactType
     * @example
     * // Get one ContactType
     * const contactType = await prisma.contactType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeFindFirstArgs} args - Arguments to find a ContactType
     * @example
     * // Get one ContactType
     * const contactType = await prisma.contactType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactTypeFindFirstArgs>(args?: SelectSubset<T, ContactTypeFindFirstArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeFindFirstOrThrowArgs} args - Arguments to find a ContactType
     * @example
     * // Get one ContactType
     * const contactType = await prisma.contactType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactTypes
     * const contactTypes = await prisma.contactType.findMany()
     * 
     * // Get first 10 ContactTypes
     * const contactTypes = await prisma.contactType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactTypeWithIdOnly = await prisma.contactType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactTypeFindManyArgs>(args?: SelectSubset<T, ContactTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactType.
     * @param {ContactTypeCreateArgs} args - Arguments to create a ContactType.
     * @example
     * // Create one ContactType
     * const ContactType = await prisma.contactType.create({
     *   data: {
     *     // ... data to create a ContactType
     *   }
     * })
     * 
     */
    create<T extends ContactTypeCreateArgs>(args: SelectSubset<T, ContactTypeCreateArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactTypes.
     * @param {ContactTypeCreateManyArgs} args - Arguments to create many ContactTypes.
     * @example
     * // Create many ContactTypes
     * const contactType = await prisma.contactType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactTypeCreateManyArgs>(args?: SelectSubset<T, ContactTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactType.
     * @param {ContactTypeDeleteArgs} args - Arguments to delete one ContactType.
     * @example
     * // Delete one ContactType
     * const ContactType = await prisma.contactType.delete({
     *   where: {
     *     // ... filter to delete one ContactType
     *   }
     * })
     * 
     */
    delete<T extends ContactTypeDeleteArgs>(args: SelectSubset<T, ContactTypeDeleteArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactType.
     * @param {ContactTypeUpdateArgs} args - Arguments to update one ContactType.
     * @example
     * // Update one ContactType
     * const contactType = await prisma.contactType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactTypeUpdateArgs>(args: SelectSubset<T, ContactTypeUpdateArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactTypes.
     * @param {ContactTypeDeleteManyArgs} args - Arguments to filter ContactTypes to delete.
     * @example
     * // Delete a few ContactTypes
     * const { count } = await prisma.contactType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactTypeDeleteManyArgs>(args?: SelectSubset<T, ContactTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactTypes
     * const contactType = await prisma.contactType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactTypeUpdateManyArgs>(args: SelectSubset<T, ContactTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactType.
     * @param {ContactTypeUpsertArgs} args - Arguments to update or create a ContactType.
     * @example
     * // Update or create a ContactType
     * const contactType = await prisma.contactType.upsert({
     *   create: {
     *     // ... data to create a ContactType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactType we want to update
     *   }
     * })
     */
    upsert<T extends ContactTypeUpsertArgs>(args: SelectSubset<T, ContactTypeUpsertArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeCountArgs} args - Arguments to filter ContactTypes to count.
     * @example
     * // Count the number of ContactTypes
     * const count = await prisma.contactType.count({
     *   where: {
     *     // ... the filter for the ContactTypes we want to count
     *   }
     * })
    **/
    count<T extends ContactTypeCountArgs>(
      args?: Subset<T, ContactTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactTypeAggregateArgs>(args: Subset<T, ContactTypeAggregateArgs>): Prisma.PrismaPromise<GetContactTypeAggregateType<T>>

    /**
     * Group by ContactType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContactTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactType model
   */
  readonly fields: ContactTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends ContactType$contactsArgs<ExtArgs> = {}>(args?: Subset<T, ContactType$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactType model
   */
  interface ContactTypeFieldRefs {
    readonly id: FieldRef<"ContactType", 'Int'>
    readonly slug: FieldRef<"ContactType", 'String'>
    readonly name: FieldRef<"ContactType", 'String'>
    readonly sortOrder: FieldRef<"ContactType", 'Int'>
    readonly createdAt: FieldRef<"ContactType", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactType findUnique
   */
  export type ContactTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactType to fetch.
     */
    where: ContactTypeWhereUniqueInput
  }

  /**
   * ContactType findUniqueOrThrow
   */
  export type ContactTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactType to fetch.
     */
    where: ContactTypeWhereUniqueInput
  }

  /**
   * ContactType findFirst
   */
  export type ContactTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactType to fetch.
     */
    where?: ContactTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTypes to fetch.
     */
    orderBy?: ContactTypeOrderByWithRelationInput | ContactTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTypes.
     */
    cursor?: ContactTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTypes.
     */
    distinct?: ContactTypeScalarFieldEnum | ContactTypeScalarFieldEnum[]
  }

  /**
   * ContactType findFirstOrThrow
   */
  export type ContactTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactType to fetch.
     */
    where?: ContactTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTypes to fetch.
     */
    orderBy?: ContactTypeOrderByWithRelationInput | ContactTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTypes.
     */
    cursor?: ContactTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTypes.
     */
    distinct?: ContactTypeScalarFieldEnum | ContactTypeScalarFieldEnum[]
  }

  /**
   * ContactType findMany
   */
  export type ContactTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactTypes to fetch.
     */
    where?: ContactTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTypes to fetch.
     */
    orderBy?: ContactTypeOrderByWithRelationInput | ContactTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactTypes.
     */
    cursor?: ContactTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTypes.
     */
    skip?: number
    distinct?: ContactTypeScalarFieldEnum | ContactTypeScalarFieldEnum[]
  }

  /**
   * ContactType create
   */
  export type ContactTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactType.
     */
    data: XOR<ContactTypeCreateInput, ContactTypeUncheckedCreateInput>
  }

  /**
   * ContactType createMany
   */
  export type ContactTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactTypes.
     */
    data: ContactTypeCreateManyInput | ContactTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactType update
   */
  export type ContactTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactType.
     */
    data: XOR<ContactTypeUpdateInput, ContactTypeUncheckedUpdateInput>
    /**
     * Choose, which ContactType to update.
     */
    where: ContactTypeWhereUniqueInput
  }

  /**
   * ContactType updateMany
   */
  export type ContactTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactTypes.
     */
    data: XOR<ContactTypeUpdateManyMutationInput, ContactTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContactTypes to update
     */
    where?: ContactTypeWhereInput
    /**
     * Limit how many ContactTypes to update.
     */
    limit?: number
  }

  /**
   * ContactType upsert
   */
  export type ContactTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactType to update in case it exists.
     */
    where: ContactTypeWhereUniqueInput
    /**
     * In case the ContactType found by the `where` argument doesn't exist, create a new ContactType with this data.
     */
    create: XOR<ContactTypeCreateInput, ContactTypeUncheckedCreateInput>
    /**
     * In case the ContactType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactTypeUpdateInput, ContactTypeUncheckedUpdateInput>
  }

  /**
   * ContactType delete
   */
  export type ContactTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter which ContactType to delete.
     */
    where: ContactTypeWhereUniqueInput
  }

  /**
   * ContactType deleteMany
   */
  export type ContactTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTypes to delete
     */
    where?: ContactTypeWhereInput
    /**
     * Limit how many ContactTypes to delete.
     */
    limit?: number
  }

  /**
   * ContactType.contacts
   */
  export type ContactType$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * ContactType without action
   */
  export type ContactTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
    cantonId: number | null
    contactTypeId: number | null
    sortOrder: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
    cantonId: number | null
    contactTypeId: number | null
    sortOrder: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    cantonId: number | null
    contactTypeId: number | null
    name: string | null
    department: string | null
    street: string | null
    postalCode: string | null
    city: string | null
    phone: string | null
    email: string | null
    website: string | null
    description: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    cantonId: number | null
    contactTypeId: number | null
    name: string | null
    department: string | null
    street: string | null
    postalCode: string | null
    city: string | null
    phone: string | null
    email: string | null
    website: string | null
    description: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    cantonId: number
    contactTypeId: number
    name: number
    department: number
    street: number
    postalCode: number
    city: number
    phone: number
    email: number
    website: number
    description: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
    cantonId?: true
    contactTypeId?: true
    sortOrder?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
    cantonId?: true
    contactTypeId?: true
    sortOrder?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    cantonId?: true
    contactTypeId?: true
    name?: true
    department?: true
    street?: true
    postalCode?: true
    city?: true
    phone?: true
    email?: true
    website?: true
    description?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    cantonId?: true
    contactTypeId?: true
    name?: true
    department?: true
    street?: true
    postalCode?: true
    city?: true
    phone?: true
    email?: true
    website?: true
    description?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    cantonId?: true
    contactTypeId?: true
    name?: true
    department?: true
    street?: true
    postalCode?: true
    city?: true
    phone?: true
    email?: true
    website?: true
    description?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    cantonId: number | null
    contactTypeId: number
    name: string
    department: string | null
    street: string | null
    postalCode: string | null
    city: string | null
    phone: string | null
    email: string | null
    website: string | null
    description: string | null
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cantonId?: boolean
    contactTypeId?: boolean
    name?: boolean
    department?: boolean
    street?: boolean
    postalCode?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canton?: boolean | Contact$cantonArgs<ExtArgs>
    contactType?: boolean | ContactTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>



  export type ContactSelectScalar = {
    id?: boolean
    cantonId?: boolean
    contactTypeId?: boolean
    name?: boolean
    department?: boolean
    street?: boolean
    postalCode?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cantonId" | "contactTypeId" | "name" | "department" | "street" | "postalCode" | "city" | "phone" | "email" | "website" | "description" | "isActive" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canton?: boolean | Contact$cantonArgs<ExtArgs>
    contactType?: boolean | ContactTypeDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      canton: Prisma.$CantonPayload<ExtArgs> | null
      contactType: Prisma.$ContactTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cantonId: number | null
      contactTypeId: number
      name: string
      department: string | null
      street: string | null
      postalCode: string | null
      city: string | null
      phone: string | null
      email: string | null
      website: string | null
      description: string | null
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canton<T extends Contact$cantonArgs<ExtArgs> = {}>(args?: Subset<T, Contact$cantonArgs<ExtArgs>>): Prisma__CantonClient<$Result.GetResult<Prisma.$CantonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contactType<T extends ContactTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactTypeDefaultArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'Int'>
    readonly cantonId: FieldRef<"Contact", 'Int'>
    readonly contactTypeId: FieldRef<"Contact", 'Int'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly department: FieldRef<"Contact", 'String'>
    readonly street: FieldRef<"Contact", 'String'>
    readonly postalCode: FieldRef<"Contact", 'String'>
    readonly city: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly website: FieldRef<"Contact", 'String'>
    readonly description: FieldRef<"Contact", 'String'>
    readonly isActive: FieldRef<"Contact", 'Boolean'>
    readonly sortOrder: FieldRef<"Contact", 'Int'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.canton
   */
  export type Contact$cantonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canton
     */
    select?: CantonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canton
     */
    omit?: CantonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CantonInclude<ExtArgs> | null
    where?: CantonWhereInput
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model DataVersion
   */

  export type AggregateDataVersion = {
    _count: DataVersionCountAggregateOutputType | null
    _avg: DataVersionAvgAggregateOutputType | null
    _sum: DataVersionSumAggregateOutputType | null
    _min: DataVersionMinAggregateOutputType | null
    _max: DataVersionMaxAggregateOutputType | null
  }

  export type DataVersionAvgAggregateOutputType = {
    id: number | null
    version: number | null
  }

  export type DataVersionSumAggregateOutputType = {
    id: number | null
    version: number | null
  }

  export type DataVersionMinAggregateOutputType = {
    id: number | null
    tableName: string | null
    version: number | null
    lastUpdated: Date | null
  }

  export type DataVersionMaxAggregateOutputType = {
    id: number | null
    tableName: string | null
    version: number | null
    lastUpdated: Date | null
  }

  export type DataVersionCountAggregateOutputType = {
    id: number
    tableName: number
    version: number
    lastUpdated: number
    _all: number
  }


  export type DataVersionAvgAggregateInputType = {
    id?: true
    version?: true
  }

  export type DataVersionSumAggregateInputType = {
    id?: true
    version?: true
  }

  export type DataVersionMinAggregateInputType = {
    id?: true
    tableName?: true
    version?: true
    lastUpdated?: true
  }

  export type DataVersionMaxAggregateInputType = {
    id?: true
    tableName?: true
    version?: true
    lastUpdated?: true
  }

  export type DataVersionCountAggregateInputType = {
    id?: true
    tableName?: true
    version?: true
    lastUpdated?: true
    _all?: true
  }

  export type DataVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataVersion to aggregate.
     */
    where?: DataVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataVersions to fetch.
     */
    orderBy?: DataVersionOrderByWithRelationInput | DataVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataVersions
    **/
    _count?: true | DataVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataVersionMaxAggregateInputType
  }

  export type GetDataVersionAggregateType<T extends DataVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateDataVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataVersion[P]>
      : GetScalarType<T[P], AggregateDataVersion[P]>
  }




  export type DataVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataVersionWhereInput
    orderBy?: DataVersionOrderByWithAggregationInput | DataVersionOrderByWithAggregationInput[]
    by: DataVersionScalarFieldEnum[] | DataVersionScalarFieldEnum
    having?: DataVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataVersionCountAggregateInputType | true
    _avg?: DataVersionAvgAggregateInputType
    _sum?: DataVersionSumAggregateInputType
    _min?: DataVersionMinAggregateInputType
    _max?: DataVersionMaxAggregateInputType
  }

  export type DataVersionGroupByOutputType = {
    id: number
    tableName: string
    version: number
    lastUpdated: Date
    _count: DataVersionCountAggregateOutputType | null
    _avg: DataVersionAvgAggregateOutputType | null
    _sum: DataVersionSumAggregateOutputType | null
    _min: DataVersionMinAggregateOutputType | null
    _max: DataVersionMaxAggregateOutputType | null
  }

  type GetDataVersionGroupByPayload<T extends DataVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataVersionGroupByOutputType[P]>
            : GetScalarType<T[P], DataVersionGroupByOutputType[P]>
        }
      >
    >


  export type DataVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    version?: boolean
    lastUpdated?: boolean
  }, ExtArgs["result"]["dataVersion"]>



  export type DataVersionSelectScalar = {
    id?: boolean
    tableName?: boolean
    version?: boolean
    lastUpdated?: boolean
  }

  export type DataVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "version" | "lastUpdated", ExtArgs["result"]["dataVersion"]>

  export type $DataVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataVersion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableName: string
      version: number
      lastUpdated: Date
    }, ExtArgs["result"]["dataVersion"]>
    composites: {}
  }

  type DataVersionGetPayload<S extends boolean | null | undefined | DataVersionDefaultArgs> = $Result.GetResult<Prisma.$DataVersionPayload, S>

  type DataVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataVersionCountAggregateInputType | true
    }

  export interface DataVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataVersion'], meta: { name: 'DataVersion' } }
    /**
     * Find zero or one DataVersion that matches the filter.
     * @param {DataVersionFindUniqueArgs} args - Arguments to find a DataVersion
     * @example
     * // Get one DataVersion
     * const dataVersion = await prisma.dataVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataVersionFindUniqueArgs>(args: SelectSubset<T, DataVersionFindUniqueArgs<ExtArgs>>): Prisma__DataVersionClient<$Result.GetResult<Prisma.$DataVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DataVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataVersionFindUniqueOrThrowArgs} args - Arguments to find a DataVersion
     * @example
     * // Get one DataVersion
     * const dataVersion = await prisma.dataVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, DataVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataVersionClient<$Result.GetResult<Prisma.$DataVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataVersionFindFirstArgs} args - Arguments to find a DataVersion
     * @example
     * // Get one DataVersion
     * const dataVersion = await prisma.dataVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataVersionFindFirstArgs>(args?: SelectSubset<T, DataVersionFindFirstArgs<ExtArgs>>): Prisma__DataVersionClient<$Result.GetResult<Prisma.$DataVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DataVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataVersionFindFirstOrThrowArgs} args - Arguments to find a DataVersion
     * @example
     * // Get one DataVersion
     * const dataVersion = await prisma.dataVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, DataVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataVersionClient<$Result.GetResult<Prisma.$DataVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DataVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataVersions
     * const dataVersions = await prisma.dataVersion.findMany()
     * 
     * // Get first 10 DataVersions
     * const dataVersions = await prisma.dataVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataVersionWithIdOnly = await prisma.dataVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataVersionFindManyArgs>(args?: SelectSubset<T, DataVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DataVersion.
     * @param {DataVersionCreateArgs} args - Arguments to create a DataVersion.
     * @example
     * // Create one DataVersion
     * const DataVersion = await prisma.dataVersion.create({
     *   data: {
     *     // ... data to create a DataVersion
     *   }
     * })
     * 
     */
    create<T extends DataVersionCreateArgs>(args: SelectSubset<T, DataVersionCreateArgs<ExtArgs>>): Prisma__DataVersionClient<$Result.GetResult<Prisma.$DataVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DataVersions.
     * @param {DataVersionCreateManyArgs} args - Arguments to create many DataVersions.
     * @example
     * // Create many DataVersions
     * const dataVersion = await prisma.dataVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataVersionCreateManyArgs>(args?: SelectSubset<T, DataVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataVersion.
     * @param {DataVersionDeleteArgs} args - Arguments to delete one DataVersion.
     * @example
     * // Delete one DataVersion
     * const DataVersion = await prisma.dataVersion.delete({
     *   where: {
     *     // ... filter to delete one DataVersion
     *   }
     * })
     * 
     */
    delete<T extends DataVersionDeleteArgs>(args: SelectSubset<T, DataVersionDeleteArgs<ExtArgs>>): Prisma__DataVersionClient<$Result.GetResult<Prisma.$DataVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DataVersion.
     * @param {DataVersionUpdateArgs} args - Arguments to update one DataVersion.
     * @example
     * // Update one DataVersion
     * const dataVersion = await prisma.dataVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataVersionUpdateArgs>(args: SelectSubset<T, DataVersionUpdateArgs<ExtArgs>>): Prisma__DataVersionClient<$Result.GetResult<Prisma.$DataVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DataVersions.
     * @param {DataVersionDeleteManyArgs} args - Arguments to filter DataVersions to delete.
     * @example
     * // Delete a few DataVersions
     * const { count } = await prisma.dataVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataVersionDeleteManyArgs>(args?: SelectSubset<T, DataVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataVersions
     * const dataVersion = await prisma.dataVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataVersionUpdateManyArgs>(args: SelectSubset<T, DataVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataVersion.
     * @param {DataVersionUpsertArgs} args - Arguments to update or create a DataVersion.
     * @example
     * // Update or create a DataVersion
     * const dataVersion = await prisma.dataVersion.upsert({
     *   create: {
     *     // ... data to create a DataVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataVersion we want to update
     *   }
     * })
     */
    upsert<T extends DataVersionUpsertArgs>(args: SelectSubset<T, DataVersionUpsertArgs<ExtArgs>>): Prisma__DataVersionClient<$Result.GetResult<Prisma.$DataVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DataVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataVersionCountArgs} args - Arguments to filter DataVersions to count.
     * @example
     * // Count the number of DataVersions
     * const count = await prisma.dataVersion.count({
     *   where: {
     *     // ... the filter for the DataVersions we want to count
     *   }
     * })
    **/
    count<T extends DataVersionCountArgs>(
      args?: Subset<T, DataVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataVersionAggregateArgs>(args: Subset<T, DataVersionAggregateArgs>): Prisma.PrismaPromise<GetDataVersionAggregateType<T>>

    /**
     * Group by DataVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataVersionGroupByArgs['orderBy'] }
        : { orderBy?: DataVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataVersion model
   */
  readonly fields: DataVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataVersion model
   */
  interface DataVersionFieldRefs {
    readonly id: FieldRef<"DataVersion", 'Int'>
    readonly tableName: FieldRef<"DataVersion", 'String'>
    readonly version: FieldRef<"DataVersion", 'Int'>
    readonly lastUpdated: FieldRef<"DataVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataVersion findUnique
   */
  export type DataVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
    /**
     * Filter, which DataVersion to fetch.
     */
    where: DataVersionWhereUniqueInput
  }

  /**
   * DataVersion findUniqueOrThrow
   */
  export type DataVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
    /**
     * Filter, which DataVersion to fetch.
     */
    where: DataVersionWhereUniqueInput
  }

  /**
   * DataVersion findFirst
   */
  export type DataVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
    /**
     * Filter, which DataVersion to fetch.
     */
    where?: DataVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataVersions to fetch.
     */
    orderBy?: DataVersionOrderByWithRelationInput | DataVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataVersions.
     */
    cursor?: DataVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataVersions.
     */
    distinct?: DataVersionScalarFieldEnum | DataVersionScalarFieldEnum[]
  }

  /**
   * DataVersion findFirstOrThrow
   */
  export type DataVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
    /**
     * Filter, which DataVersion to fetch.
     */
    where?: DataVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataVersions to fetch.
     */
    orderBy?: DataVersionOrderByWithRelationInput | DataVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataVersions.
     */
    cursor?: DataVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataVersions.
     */
    distinct?: DataVersionScalarFieldEnum | DataVersionScalarFieldEnum[]
  }

  /**
   * DataVersion findMany
   */
  export type DataVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
    /**
     * Filter, which DataVersions to fetch.
     */
    where?: DataVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataVersions to fetch.
     */
    orderBy?: DataVersionOrderByWithRelationInput | DataVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataVersions.
     */
    cursor?: DataVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataVersions.
     */
    skip?: number
    distinct?: DataVersionScalarFieldEnum | DataVersionScalarFieldEnum[]
  }

  /**
   * DataVersion create
   */
  export type DataVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
    /**
     * The data needed to create a DataVersion.
     */
    data: XOR<DataVersionCreateInput, DataVersionUncheckedCreateInput>
  }

  /**
   * DataVersion createMany
   */
  export type DataVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataVersions.
     */
    data: DataVersionCreateManyInput | DataVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataVersion update
   */
  export type DataVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
    /**
     * The data needed to update a DataVersion.
     */
    data: XOR<DataVersionUpdateInput, DataVersionUncheckedUpdateInput>
    /**
     * Choose, which DataVersion to update.
     */
    where: DataVersionWhereUniqueInput
  }

  /**
   * DataVersion updateMany
   */
  export type DataVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataVersions.
     */
    data: XOR<DataVersionUpdateManyMutationInput, DataVersionUncheckedUpdateManyInput>
    /**
     * Filter which DataVersions to update
     */
    where?: DataVersionWhereInput
    /**
     * Limit how many DataVersions to update.
     */
    limit?: number
  }

  /**
   * DataVersion upsert
   */
  export type DataVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
    /**
     * The filter to search for the DataVersion to update in case it exists.
     */
    where: DataVersionWhereUniqueInput
    /**
     * In case the DataVersion found by the `where` argument doesn't exist, create a new DataVersion with this data.
     */
    create: XOR<DataVersionCreateInput, DataVersionUncheckedCreateInput>
    /**
     * In case the DataVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataVersionUpdateInput, DataVersionUncheckedUpdateInput>
  }

  /**
   * DataVersion delete
   */
  export type DataVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
    /**
     * Filter which DataVersion to delete.
     */
    where: DataVersionWhereUniqueInput
  }

  /**
   * DataVersion deleteMany
   */
  export type DataVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataVersions to delete
     */
    where?: DataVersionWhereInput
    /**
     * Limit how many DataVersions to delete.
     */
    limit?: number
  }

  /**
   * DataVersion without action
   */
  export type DataVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataVersion
     */
    select?: DataVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataVersion
     */
    omit?: DataVersionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CantonScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    nameOfficial: 'nameOfficial',
    coatOfArms: 'coatOfArms',
    language: 'language',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CantonScalarFieldEnum = (typeof CantonScalarFieldEnum)[keyof typeof CantonScalarFieldEnum]


  export const RegulationCategoryScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    icon: 'icon',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RegulationCategoryScalarFieldEnum = (typeof RegulationCategoryScalarFieldEnum)[keyof typeof RegulationCategoryScalarFieldEnum]


  export const RegulationScalarFieldEnum: {
    id: 'id',
    cantonId: 'cantonId',
    categoryId: 'categoryId',
    title: 'title',
    summary: 'summary',
    content: 'content',
    legalReference: 'legalReference',
    sourceUrl: 'sourceUrl',
    effectiveDate: 'effectiveDate',
    isActive: 'isActive',
    version: 'version',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RegulationScalarFieldEnum = (typeof RegulationScalarFieldEnum)[keyof typeof RegulationScalarFieldEnum]


  export const CalculationTypeScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    description: 'description',
    formula: 'formula',
    icon: 'icon',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalculationTypeScalarFieldEnum = (typeof CalculationTypeScalarFieldEnum)[keyof typeof CalculationTypeScalarFieldEnum]


  export const CalculationParameterScalarFieldEnum: {
    id: 'id',
    calculationTypeId: 'calculationTypeId',
    cantonId: 'cantonId',
    parameterKey: 'parameterKey',
    parameterValue: 'parameterValue',
    valueType: 'valueType',
    unit: 'unit',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalculationParameterScalarFieldEnum = (typeof CalculationParameterScalarFieldEnum)[keyof typeof CalculationParameterScalarFieldEnum]


  export const ExampleCategoryScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    icon: 'icon',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExampleCategoryScalarFieldEnum = (typeof ExampleCategoryScalarFieldEnum)[keyof typeof ExampleCategoryScalarFieldEnum]


  export const ExampleScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    cantonId: 'cantonId',
    title: 'title',
    description: 'description',
    content: 'content',
    eventType: 'eventType',
    capacity: 'capacity',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExampleScalarFieldEnum = (typeof ExampleScalarFieldEnum)[keyof typeof ExampleScalarFieldEnum]


  export const ContactTypeScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactTypeScalarFieldEnum = (typeof ContactTypeScalarFieldEnum)[keyof typeof ContactTypeScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    cantonId: 'cantonId',
    contactTypeId: 'contactTypeId',
    name: 'name',
    department: 'department',
    street: 'street',
    postalCode: 'postalCode',
    city: 'city',
    phone: 'phone',
    email: 'email',
    website: 'website',
    description: 'description',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const DataVersionScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    version: 'version',
    lastUpdated: 'lastUpdated'
  };

  export type DataVersionScalarFieldEnum = (typeof DataVersionScalarFieldEnum)[keyof typeof DataVersionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const CantonOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    nameOfficial: 'nameOfficial',
    coatOfArms: 'coatOfArms'
  };

  export type CantonOrderByRelevanceFieldEnum = (typeof CantonOrderByRelevanceFieldEnum)[keyof typeof CantonOrderByRelevanceFieldEnum]


  export const RegulationCategoryOrderByRelevanceFieldEnum: {
    slug: 'slug',
    name: 'name',
    description: 'description',
    icon: 'icon'
  };

  export type RegulationCategoryOrderByRelevanceFieldEnum = (typeof RegulationCategoryOrderByRelevanceFieldEnum)[keyof typeof RegulationCategoryOrderByRelevanceFieldEnum]


  export const RegulationOrderByRelevanceFieldEnum: {
    title: 'title',
    summary: 'summary',
    content: 'content',
    legalReference: 'legalReference',
    sourceUrl: 'sourceUrl'
  };

  export type RegulationOrderByRelevanceFieldEnum = (typeof RegulationOrderByRelevanceFieldEnum)[keyof typeof RegulationOrderByRelevanceFieldEnum]


  export const CalculationTypeOrderByRelevanceFieldEnum: {
    slug: 'slug',
    name: 'name',
    description: 'description',
    formula: 'formula',
    icon: 'icon'
  };

  export type CalculationTypeOrderByRelevanceFieldEnum = (typeof CalculationTypeOrderByRelevanceFieldEnum)[keyof typeof CalculationTypeOrderByRelevanceFieldEnum]


  export const CalculationParameterOrderByRelevanceFieldEnum: {
    parameterKey: 'parameterKey',
    parameterValue: 'parameterValue',
    unit: 'unit',
    description: 'description'
  };

  export type CalculationParameterOrderByRelevanceFieldEnum = (typeof CalculationParameterOrderByRelevanceFieldEnum)[keyof typeof CalculationParameterOrderByRelevanceFieldEnum]


  export const ExampleCategoryOrderByRelevanceFieldEnum: {
    slug: 'slug',
    name: 'name',
    icon: 'icon'
  };

  export type ExampleCategoryOrderByRelevanceFieldEnum = (typeof ExampleCategoryOrderByRelevanceFieldEnum)[keyof typeof ExampleCategoryOrderByRelevanceFieldEnum]


  export const ExampleOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    content: 'content',
    eventType: 'eventType',
    imageUrl: 'imageUrl'
  };

  export type ExampleOrderByRelevanceFieldEnum = (typeof ExampleOrderByRelevanceFieldEnum)[keyof typeof ExampleOrderByRelevanceFieldEnum]


  export const ContactTypeOrderByRelevanceFieldEnum: {
    slug: 'slug',
    name: 'name'
  };

  export type ContactTypeOrderByRelevanceFieldEnum = (typeof ContactTypeOrderByRelevanceFieldEnum)[keyof typeof ContactTypeOrderByRelevanceFieldEnum]


  export const ContactOrderByRelevanceFieldEnum: {
    name: 'name',
    department: 'department',
    street: 'street',
    postalCode: 'postalCode',
    city: 'city',
    phone: 'phone',
    email: 'email',
    website: 'website',
    description: 'description'
  };

  export type ContactOrderByRelevanceFieldEnum = (typeof ContactOrderByRelevanceFieldEnum)[keyof typeof ContactOrderByRelevanceFieldEnum]


  export const DataVersionOrderByRelevanceFieldEnum: {
    tableName: 'tableName'
  };

  export type DataVersionOrderByRelevanceFieldEnum = (typeof DataVersionOrderByRelevanceFieldEnum)[keyof typeof DataVersionOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'CantonLanguage'
   */
  export type EnumCantonLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CantonLanguage'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ValueType'
   */
  export type EnumValueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ValueType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type CantonWhereInput = {
    AND?: CantonWhereInput | CantonWhereInput[]
    OR?: CantonWhereInput[]
    NOT?: CantonWhereInput | CantonWhereInput[]
    id?: IntFilter<"Canton"> | number
    code?: StringFilter<"Canton"> | string
    name?: StringFilter<"Canton"> | string
    nameOfficial?: StringFilter<"Canton"> | string
    coatOfArms?: StringNullableFilter<"Canton"> | string | null
    language?: EnumCantonLanguageFilter<"Canton"> | $Enums.CantonLanguage
    sortOrder?: IntFilter<"Canton"> | number
    createdAt?: DateTimeFilter<"Canton"> | Date | string
    updatedAt?: DateTimeFilter<"Canton"> | Date | string
    regulations?: RegulationListRelationFilter
    contacts?: ContactListRelationFilter
    calculationParams?: CalculationParameterListRelationFilter
    examples?: ExampleListRelationFilter
  }

  export type CantonOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameOfficial?: SortOrder
    coatOfArms?: SortOrderInput | SortOrder
    language?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    regulations?: RegulationOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    calculationParams?: CalculationParameterOrderByRelationAggregateInput
    examples?: ExampleOrderByRelationAggregateInput
    _relevance?: CantonOrderByRelevanceInput
  }

  export type CantonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: CantonWhereInput | CantonWhereInput[]
    OR?: CantonWhereInput[]
    NOT?: CantonWhereInput | CantonWhereInput[]
    name?: StringFilter<"Canton"> | string
    nameOfficial?: StringFilter<"Canton"> | string
    coatOfArms?: StringNullableFilter<"Canton"> | string | null
    language?: EnumCantonLanguageFilter<"Canton"> | $Enums.CantonLanguage
    sortOrder?: IntFilter<"Canton"> | number
    createdAt?: DateTimeFilter<"Canton"> | Date | string
    updatedAt?: DateTimeFilter<"Canton"> | Date | string
    regulations?: RegulationListRelationFilter
    contacts?: ContactListRelationFilter
    calculationParams?: CalculationParameterListRelationFilter
    examples?: ExampleListRelationFilter
  }, "id" | "code">

  export type CantonOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameOfficial?: SortOrder
    coatOfArms?: SortOrderInput | SortOrder
    language?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CantonCountOrderByAggregateInput
    _avg?: CantonAvgOrderByAggregateInput
    _max?: CantonMaxOrderByAggregateInput
    _min?: CantonMinOrderByAggregateInput
    _sum?: CantonSumOrderByAggregateInput
  }

  export type CantonScalarWhereWithAggregatesInput = {
    AND?: CantonScalarWhereWithAggregatesInput | CantonScalarWhereWithAggregatesInput[]
    OR?: CantonScalarWhereWithAggregatesInput[]
    NOT?: CantonScalarWhereWithAggregatesInput | CantonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Canton"> | number
    code?: StringWithAggregatesFilter<"Canton"> | string
    name?: StringWithAggregatesFilter<"Canton"> | string
    nameOfficial?: StringWithAggregatesFilter<"Canton"> | string
    coatOfArms?: StringNullableWithAggregatesFilter<"Canton"> | string | null
    language?: EnumCantonLanguageWithAggregatesFilter<"Canton"> | $Enums.CantonLanguage
    sortOrder?: IntWithAggregatesFilter<"Canton"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Canton"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Canton"> | Date | string
  }

  export type RegulationCategoryWhereInput = {
    AND?: RegulationCategoryWhereInput | RegulationCategoryWhereInput[]
    OR?: RegulationCategoryWhereInput[]
    NOT?: RegulationCategoryWhereInput | RegulationCategoryWhereInput[]
    id?: IntFilter<"RegulationCategory"> | number
    slug?: StringFilter<"RegulationCategory"> | string
    name?: StringFilter<"RegulationCategory"> | string
    description?: StringNullableFilter<"RegulationCategory"> | string | null
    icon?: StringNullableFilter<"RegulationCategory"> | string | null
    sortOrder?: IntFilter<"RegulationCategory"> | number
    createdAt?: DateTimeFilter<"RegulationCategory"> | Date | string
    updatedAt?: DateTimeFilter<"RegulationCategory"> | Date | string
    regulations?: RegulationListRelationFilter
  }

  export type RegulationCategoryOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    regulations?: RegulationOrderByRelationAggregateInput
    _relevance?: RegulationCategoryOrderByRelevanceInput
  }

  export type RegulationCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: RegulationCategoryWhereInput | RegulationCategoryWhereInput[]
    OR?: RegulationCategoryWhereInput[]
    NOT?: RegulationCategoryWhereInput | RegulationCategoryWhereInput[]
    name?: StringFilter<"RegulationCategory"> | string
    description?: StringNullableFilter<"RegulationCategory"> | string | null
    icon?: StringNullableFilter<"RegulationCategory"> | string | null
    sortOrder?: IntFilter<"RegulationCategory"> | number
    createdAt?: DateTimeFilter<"RegulationCategory"> | Date | string
    updatedAt?: DateTimeFilter<"RegulationCategory"> | Date | string
    regulations?: RegulationListRelationFilter
  }, "id" | "slug">

  export type RegulationCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RegulationCategoryCountOrderByAggregateInput
    _avg?: RegulationCategoryAvgOrderByAggregateInput
    _max?: RegulationCategoryMaxOrderByAggregateInput
    _min?: RegulationCategoryMinOrderByAggregateInput
    _sum?: RegulationCategorySumOrderByAggregateInput
  }

  export type RegulationCategoryScalarWhereWithAggregatesInput = {
    AND?: RegulationCategoryScalarWhereWithAggregatesInput | RegulationCategoryScalarWhereWithAggregatesInput[]
    OR?: RegulationCategoryScalarWhereWithAggregatesInput[]
    NOT?: RegulationCategoryScalarWhereWithAggregatesInput | RegulationCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegulationCategory"> | number
    slug?: StringWithAggregatesFilter<"RegulationCategory"> | string
    name?: StringWithAggregatesFilter<"RegulationCategory"> | string
    description?: StringNullableWithAggregatesFilter<"RegulationCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"RegulationCategory"> | string | null
    sortOrder?: IntWithAggregatesFilter<"RegulationCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RegulationCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RegulationCategory"> | Date | string
  }

  export type RegulationWhereInput = {
    AND?: RegulationWhereInput | RegulationWhereInput[]
    OR?: RegulationWhereInput[]
    NOT?: RegulationWhereInput | RegulationWhereInput[]
    id?: IntFilter<"Regulation"> | number
    cantonId?: IntFilter<"Regulation"> | number
    categoryId?: IntFilter<"Regulation"> | number
    title?: StringFilter<"Regulation"> | string
    summary?: StringFilter<"Regulation"> | string
    content?: StringFilter<"Regulation"> | string
    legalReference?: StringNullableFilter<"Regulation"> | string | null
    sourceUrl?: StringNullableFilter<"Regulation"> | string | null
    effectiveDate?: DateTimeNullableFilter<"Regulation"> | Date | string | null
    isActive?: BoolFilter<"Regulation"> | boolean
    version?: IntFilter<"Regulation"> | number
    sortOrder?: IntFilter<"Regulation"> | number
    createdAt?: DateTimeFilter<"Regulation"> | Date | string
    updatedAt?: DateTimeFilter<"Regulation"> | Date | string
    canton?: XOR<CantonScalarRelationFilter, CantonWhereInput>
    category?: XOR<RegulationCategoryScalarRelationFilter, RegulationCategoryWhereInput>
  }

  export type RegulationOrderByWithRelationInput = {
    id?: SortOrder
    cantonId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    legalReference?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    effectiveDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    version?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canton?: CantonOrderByWithRelationInput
    category?: RegulationCategoryOrderByWithRelationInput
    _relevance?: RegulationOrderByRelevanceInput
  }

  export type RegulationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegulationWhereInput | RegulationWhereInput[]
    OR?: RegulationWhereInput[]
    NOT?: RegulationWhereInput | RegulationWhereInput[]
    cantonId?: IntFilter<"Regulation"> | number
    categoryId?: IntFilter<"Regulation"> | number
    title?: StringFilter<"Regulation"> | string
    summary?: StringFilter<"Regulation"> | string
    content?: StringFilter<"Regulation"> | string
    legalReference?: StringNullableFilter<"Regulation"> | string | null
    sourceUrl?: StringNullableFilter<"Regulation"> | string | null
    effectiveDate?: DateTimeNullableFilter<"Regulation"> | Date | string | null
    isActive?: BoolFilter<"Regulation"> | boolean
    version?: IntFilter<"Regulation"> | number
    sortOrder?: IntFilter<"Regulation"> | number
    createdAt?: DateTimeFilter<"Regulation"> | Date | string
    updatedAt?: DateTimeFilter<"Regulation"> | Date | string
    canton?: XOR<CantonScalarRelationFilter, CantonWhereInput>
    category?: XOR<RegulationCategoryScalarRelationFilter, RegulationCategoryWhereInput>
  }, "id">

  export type RegulationOrderByWithAggregationInput = {
    id?: SortOrder
    cantonId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    legalReference?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    effectiveDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    version?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RegulationCountOrderByAggregateInput
    _avg?: RegulationAvgOrderByAggregateInput
    _max?: RegulationMaxOrderByAggregateInput
    _min?: RegulationMinOrderByAggregateInput
    _sum?: RegulationSumOrderByAggregateInput
  }

  export type RegulationScalarWhereWithAggregatesInput = {
    AND?: RegulationScalarWhereWithAggregatesInput | RegulationScalarWhereWithAggregatesInput[]
    OR?: RegulationScalarWhereWithAggregatesInput[]
    NOT?: RegulationScalarWhereWithAggregatesInput | RegulationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Regulation"> | number
    cantonId?: IntWithAggregatesFilter<"Regulation"> | number
    categoryId?: IntWithAggregatesFilter<"Regulation"> | number
    title?: StringWithAggregatesFilter<"Regulation"> | string
    summary?: StringWithAggregatesFilter<"Regulation"> | string
    content?: StringWithAggregatesFilter<"Regulation"> | string
    legalReference?: StringNullableWithAggregatesFilter<"Regulation"> | string | null
    sourceUrl?: StringNullableWithAggregatesFilter<"Regulation"> | string | null
    effectiveDate?: DateTimeNullableWithAggregatesFilter<"Regulation"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Regulation"> | boolean
    version?: IntWithAggregatesFilter<"Regulation"> | number
    sortOrder?: IntWithAggregatesFilter<"Regulation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Regulation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Regulation"> | Date | string
  }

  export type CalculationTypeWhereInput = {
    AND?: CalculationTypeWhereInput | CalculationTypeWhereInput[]
    OR?: CalculationTypeWhereInput[]
    NOT?: CalculationTypeWhereInput | CalculationTypeWhereInput[]
    id?: IntFilter<"CalculationType"> | number
    slug?: StringFilter<"CalculationType"> | string
    name?: StringFilter<"CalculationType"> | string
    description?: StringNullableFilter<"CalculationType"> | string | null
    formula?: StringNullableFilter<"CalculationType"> | string | null
    icon?: StringNullableFilter<"CalculationType"> | string | null
    sortOrder?: IntFilter<"CalculationType"> | number
    createdAt?: DateTimeFilter<"CalculationType"> | Date | string
    updatedAt?: DateTimeFilter<"CalculationType"> | Date | string
    parameters?: CalculationParameterListRelationFilter
  }

  export type CalculationTypeOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    formula?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parameters?: CalculationParameterOrderByRelationAggregateInput
    _relevance?: CalculationTypeOrderByRelevanceInput
  }

  export type CalculationTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: CalculationTypeWhereInput | CalculationTypeWhereInput[]
    OR?: CalculationTypeWhereInput[]
    NOT?: CalculationTypeWhereInput | CalculationTypeWhereInput[]
    name?: StringFilter<"CalculationType"> | string
    description?: StringNullableFilter<"CalculationType"> | string | null
    formula?: StringNullableFilter<"CalculationType"> | string | null
    icon?: StringNullableFilter<"CalculationType"> | string | null
    sortOrder?: IntFilter<"CalculationType"> | number
    createdAt?: DateTimeFilter<"CalculationType"> | Date | string
    updatedAt?: DateTimeFilter<"CalculationType"> | Date | string
    parameters?: CalculationParameterListRelationFilter
  }, "id" | "slug">

  export type CalculationTypeOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    formula?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalculationTypeCountOrderByAggregateInput
    _avg?: CalculationTypeAvgOrderByAggregateInput
    _max?: CalculationTypeMaxOrderByAggregateInput
    _min?: CalculationTypeMinOrderByAggregateInput
    _sum?: CalculationTypeSumOrderByAggregateInput
  }

  export type CalculationTypeScalarWhereWithAggregatesInput = {
    AND?: CalculationTypeScalarWhereWithAggregatesInput | CalculationTypeScalarWhereWithAggregatesInput[]
    OR?: CalculationTypeScalarWhereWithAggregatesInput[]
    NOT?: CalculationTypeScalarWhereWithAggregatesInput | CalculationTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CalculationType"> | number
    slug?: StringWithAggregatesFilter<"CalculationType"> | string
    name?: StringWithAggregatesFilter<"CalculationType"> | string
    description?: StringNullableWithAggregatesFilter<"CalculationType"> | string | null
    formula?: StringNullableWithAggregatesFilter<"CalculationType"> | string | null
    icon?: StringNullableWithAggregatesFilter<"CalculationType"> | string | null
    sortOrder?: IntWithAggregatesFilter<"CalculationType"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CalculationType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalculationType"> | Date | string
  }

  export type CalculationParameterWhereInput = {
    AND?: CalculationParameterWhereInput | CalculationParameterWhereInput[]
    OR?: CalculationParameterWhereInput[]
    NOT?: CalculationParameterWhereInput | CalculationParameterWhereInput[]
    id?: IntFilter<"CalculationParameter"> | number
    calculationTypeId?: IntFilter<"CalculationParameter"> | number
    cantonId?: IntNullableFilter<"CalculationParameter"> | number | null
    parameterKey?: StringFilter<"CalculationParameter"> | string
    parameterValue?: StringFilter<"CalculationParameter"> | string
    valueType?: EnumValueTypeFilter<"CalculationParameter"> | $Enums.ValueType
    unit?: StringNullableFilter<"CalculationParameter"> | string | null
    description?: StringNullableFilter<"CalculationParameter"> | string | null
    createdAt?: DateTimeFilter<"CalculationParameter"> | Date | string
    updatedAt?: DateTimeFilter<"CalculationParameter"> | Date | string
    calculationType?: XOR<CalculationTypeScalarRelationFilter, CalculationTypeWhereInput>
    canton?: XOR<CantonNullableScalarRelationFilter, CantonWhereInput> | null
  }

  export type CalculationParameterOrderByWithRelationInput = {
    id?: SortOrder
    calculationTypeId?: SortOrder
    cantonId?: SortOrderInput | SortOrder
    parameterKey?: SortOrder
    parameterValue?: SortOrder
    valueType?: SortOrder
    unit?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    calculationType?: CalculationTypeOrderByWithRelationInput
    canton?: CantonOrderByWithRelationInput
    _relevance?: CalculationParameterOrderByRelevanceInput
  }

  export type CalculationParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    calculationTypeId_cantonId_parameterKey?: CalculationParameterCalculationTypeIdCantonIdParameterKeyCompoundUniqueInput
    AND?: CalculationParameterWhereInput | CalculationParameterWhereInput[]
    OR?: CalculationParameterWhereInput[]
    NOT?: CalculationParameterWhereInput | CalculationParameterWhereInput[]
    calculationTypeId?: IntFilter<"CalculationParameter"> | number
    cantonId?: IntNullableFilter<"CalculationParameter"> | number | null
    parameterKey?: StringFilter<"CalculationParameter"> | string
    parameterValue?: StringFilter<"CalculationParameter"> | string
    valueType?: EnumValueTypeFilter<"CalculationParameter"> | $Enums.ValueType
    unit?: StringNullableFilter<"CalculationParameter"> | string | null
    description?: StringNullableFilter<"CalculationParameter"> | string | null
    createdAt?: DateTimeFilter<"CalculationParameter"> | Date | string
    updatedAt?: DateTimeFilter<"CalculationParameter"> | Date | string
    calculationType?: XOR<CalculationTypeScalarRelationFilter, CalculationTypeWhereInput>
    canton?: XOR<CantonNullableScalarRelationFilter, CantonWhereInput> | null
  }, "id" | "calculationTypeId_cantonId_parameterKey">

  export type CalculationParameterOrderByWithAggregationInput = {
    id?: SortOrder
    calculationTypeId?: SortOrder
    cantonId?: SortOrderInput | SortOrder
    parameterKey?: SortOrder
    parameterValue?: SortOrder
    valueType?: SortOrder
    unit?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalculationParameterCountOrderByAggregateInput
    _avg?: CalculationParameterAvgOrderByAggregateInput
    _max?: CalculationParameterMaxOrderByAggregateInput
    _min?: CalculationParameterMinOrderByAggregateInput
    _sum?: CalculationParameterSumOrderByAggregateInput
  }

  export type CalculationParameterScalarWhereWithAggregatesInput = {
    AND?: CalculationParameterScalarWhereWithAggregatesInput | CalculationParameterScalarWhereWithAggregatesInput[]
    OR?: CalculationParameterScalarWhereWithAggregatesInput[]
    NOT?: CalculationParameterScalarWhereWithAggregatesInput | CalculationParameterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CalculationParameter"> | number
    calculationTypeId?: IntWithAggregatesFilter<"CalculationParameter"> | number
    cantonId?: IntNullableWithAggregatesFilter<"CalculationParameter"> | number | null
    parameterKey?: StringWithAggregatesFilter<"CalculationParameter"> | string
    parameterValue?: StringWithAggregatesFilter<"CalculationParameter"> | string
    valueType?: EnumValueTypeWithAggregatesFilter<"CalculationParameter"> | $Enums.ValueType
    unit?: StringNullableWithAggregatesFilter<"CalculationParameter"> | string | null
    description?: StringNullableWithAggregatesFilter<"CalculationParameter"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CalculationParameter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalculationParameter"> | Date | string
  }

  export type ExampleCategoryWhereInput = {
    AND?: ExampleCategoryWhereInput | ExampleCategoryWhereInput[]
    OR?: ExampleCategoryWhereInput[]
    NOT?: ExampleCategoryWhereInput | ExampleCategoryWhereInput[]
    id?: IntFilter<"ExampleCategory"> | number
    slug?: StringFilter<"ExampleCategory"> | string
    name?: StringFilter<"ExampleCategory"> | string
    icon?: StringNullableFilter<"ExampleCategory"> | string | null
    sortOrder?: IntFilter<"ExampleCategory"> | number
    createdAt?: DateTimeFilter<"ExampleCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExampleCategory"> | Date | string
    examples?: ExampleListRelationFilter
  }

  export type ExampleCategoryOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examples?: ExampleOrderByRelationAggregateInput
    _relevance?: ExampleCategoryOrderByRelevanceInput
  }

  export type ExampleCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: ExampleCategoryWhereInput | ExampleCategoryWhereInput[]
    OR?: ExampleCategoryWhereInput[]
    NOT?: ExampleCategoryWhereInput | ExampleCategoryWhereInput[]
    name?: StringFilter<"ExampleCategory"> | string
    icon?: StringNullableFilter<"ExampleCategory"> | string | null
    sortOrder?: IntFilter<"ExampleCategory"> | number
    createdAt?: DateTimeFilter<"ExampleCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExampleCategory"> | Date | string
    examples?: ExampleListRelationFilter
  }, "id" | "slug">

  export type ExampleCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExampleCategoryCountOrderByAggregateInput
    _avg?: ExampleCategoryAvgOrderByAggregateInput
    _max?: ExampleCategoryMaxOrderByAggregateInput
    _min?: ExampleCategoryMinOrderByAggregateInput
    _sum?: ExampleCategorySumOrderByAggregateInput
  }

  export type ExampleCategoryScalarWhereWithAggregatesInput = {
    AND?: ExampleCategoryScalarWhereWithAggregatesInput | ExampleCategoryScalarWhereWithAggregatesInput[]
    OR?: ExampleCategoryScalarWhereWithAggregatesInput[]
    NOT?: ExampleCategoryScalarWhereWithAggregatesInput | ExampleCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExampleCategory"> | number
    slug?: StringWithAggregatesFilter<"ExampleCategory"> | string
    name?: StringWithAggregatesFilter<"ExampleCategory"> | string
    icon?: StringNullableWithAggregatesFilter<"ExampleCategory"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ExampleCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExampleCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExampleCategory"> | Date | string
  }

  export type ExampleWhereInput = {
    AND?: ExampleWhereInput | ExampleWhereInput[]
    OR?: ExampleWhereInput[]
    NOT?: ExampleWhereInput | ExampleWhereInput[]
    id?: IntFilter<"Example"> | number
    categoryId?: IntFilter<"Example"> | number
    cantonId?: IntNullableFilter<"Example"> | number | null
    title?: StringFilter<"Example"> | string
    description?: StringFilter<"Example"> | string
    content?: StringFilter<"Example"> | string
    eventType?: StringNullableFilter<"Example"> | string | null
    capacity?: IntNullableFilter<"Example"> | number | null
    imageUrl?: StringNullableFilter<"Example"> | string | null
    isActive?: BoolFilter<"Example"> | boolean
    sortOrder?: IntFilter<"Example"> | number
    createdAt?: DateTimeFilter<"Example"> | Date | string
    updatedAt?: DateTimeFilter<"Example"> | Date | string
    category?: XOR<ExampleCategoryScalarRelationFilter, ExampleCategoryWhereInput>
    canton?: XOR<CantonNullableScalarRelationFilter, CantonWhereInput> | null
  }

  export type ExampleOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    cantonId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    eventType?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: ExampleCategoryOrderByWithRelationInput
    canton?: CantonOrderByWithRelationInput
    _relevance?: ExampleOrderByRelevanceInput
  }

  export type ExampleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExampleWhereInput | ExampleWhereInput[]
    OR?: ExampleWhereInput[]
    NOT?: ExampleWhereInput | ExampleWhereInput[]
    categoryId?: IntFilter<"Example"> | number
    cantonId?: IntNullableFilter<"Example"> | number | null
    title?: StringFilter<"Example"> | string
    description?: StringFilter<"Example"> | string
    content?: StringFilter<"Example"> | string
    eventType?: StringNullableFilter<"Example"> | string | null
    capacity?: IntNullableFilter<"Example"> | number | null
    imageUrl?: StringNullableFilter<"Example"> | string | null
    isActive?: BoolFilter<"Example"> | boolean
    sortOrder?: IntFilter<"Example"> | number
    createdAt?: DateTimeFilter<"Example"> | Date | string
    updatedAt?: DateTimeFilter<"Example"> | Date | string
    category?: XOR<ExampleCategoryScalarRelationFilter, ExampleCategoryWhereInput>
    canton?: XOR<CantonNullableScalarRelationFilter, CantonWhereInput> | null
  }, "id">

  export type ExampleOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    cantonId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    eventType?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExampleCountOrderByAggregateInput
    _avg?: ExampleAvgOrderByAggregateInput
    _max?: ExampleMaxOrderByAggregateInput
    _min?: ExampleMinOrderByAggregateInput
    _sum?: ExampleSumOrderByAggregateInput
  }

  export type ExampleScalarWhereWithAggregatesInput = {
    AND?: ExampleScalarWhereWithAggregatesInput | ExampleScalarWhereWithAggregatesInput[]
    OR?: ExampleScalarWhereWithAggregatesInput[]
    NOT?: ExampleScalarWhereWithAggregatesInput | ExampleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Example"> | number
    categoryId?: IntWithAggregatesFilter<"Example"> | number
    cantonId?: IntNullableWithAggregatesFilter<"Example"> | number | null
    title?: StringWithAggregatesFilter<"Example"> | string
    description?: StringWithAggregatesFilter<"Example"> | string
    content?: StringWithAggregatesFilter<"Example"> | string
    eventType?: StringNullableWithAggregatesFilter<"Example"> | string | null
    capacity?: IntNullableWithAggregatesFilter<"Example"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"Example"> | string | null
    isActive?: BoolWithAggregatesFilter<"Example"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Example"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Example"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Example"> | Date | string
  }

  export type ContactTypeWhereInput = {
    AND?: ContactTypeWhereInput | ContactTypeWhereInput[]
    OR?: ContactTypeWhereInput[]
    NOT?: ContactTypeWhereInput | ContactTypeWhereInput[]
    id?: IntFilter<"ContactType"> | number
    slug?: StringFilter<"ContactType"> | string
    name?: StringFilter<"ContactType"> | string
    sortOrder?: IntFilter<"ContactType"> | number
    createdAt?: DateTimeFilter<"ContactType"> | Date | string
    updatedAt?: DateTimeFilter<"ContactType"> | Date | string
    contacts?: ContactListRelationFilter
  }

  export type ContactTypeOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contacts?: ContactOrderByRelationAggregateInput
    _relevance?: ContactTypeOrderByRelevanceInput
  }

  export type ContactTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: ContactTypeWhereInput | ContactTypeWhereInput[]
    OR?: ContactTypeWhereInput[]
    NOT?: ContactTypeWhereInput | ContactTypeWhereInput[]
    name?: StringFilter<"ContactType"> | string
    sortOrder?: IntFilter<"ContactType"> | number
    createdAt?: DateTimeFilter<"ContactType"> | Date | string
    updatedAt?: DateTimeFilter<"ContactType"> | Date | string
    contacts?: ContactListRelationFilter
  }, "id" | "slug">

  export type ContactTypeOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactTypeCountOrderByAggregateInput
    _avg?: ContactTypeAvgOrderByAggregateInput
    _max?: ContactTypeMaxOrderByAggregateInput
    _min?: ContactTypeMinOrderByAggregateInput
    _sum?: ContactTypeSumOrderByAggregateInput
  }

  export type ContactTypeScalarWhereWithAggregatesInput = {
    AND?: ContactTypeScalarWhereWithAggregatesInput | ContactTypeScalarWhereWithAggregatesInput[]
    OR?: ContactTypeScalarWhereWithAggregatesInput[]
    NOT?: ContactTypeScalarWhereWithAggregatesInput | ContactTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactType"> | number
    slug?: StringWithAggregatesFilter<"ContactType"> | string
    name?: StringWithAggregatesFilter<"ContactType"> | string
    sortOrder?: IntWithAggregatesFilter<"ContactType"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContactType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactType"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: IntFilter<"Contact"> | number
    cantonId?: IntNullableFilter<"Contact"> | number | null
    contactTypeId?: IntFilter<"Contact"> | number
    name?: StringFilter<"Contact"> | string
    department?: StringNullableFilter<"Contact"> | string | null
    street?: StringNullableFilter<"Contact"> | string | null
    postalCode?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    description?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    sortOrder?: IntFilter<"Contact"> | number
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    canton?: XOR<CantonNullableScalarRelationFilter, CantonWhereInput> | null
    contactType?: XOR<ContactTypeScalarRelationFilter, ContactTypeWhereInput>
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    cantonId?: SortOrderInput | SortOrder
    contactTypeId?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canton?: CantonOrderByWithRelationInput
    contactType?: ContactTypeOrderByWithRelationInput
    _relevance?: ContactOrderByRelevanceInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    cantonId?: IntNullableFilter<"Contact"> | number | null
    contactTypeId?: IntFilter<"Contact"> | number
    name?: StringFilter<"Contact"> | string
    department?: StringNullableFilter<"Contact"> | string | null
    street?: StringNullableFilter<"Contact"> | string | null
    postalCode?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    description?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    sortOrder?: IntFilter<"Contact"> | number
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    canton?: XOR<CantonNullableScalarRelationFilter, CantonWhereInput> | null
    contactType?: XOR<ContactTypeScalarRelationFilter, ContactTypeWhereInput>
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    cantonId?: SortOrderInput | SortOrder
    contactTypeId?: SortOrder
    name?: SortOrder
    department?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact"> | number
    cantonId?: IntNullableWithAggregatesFilter<"Contact"> | number | null
    contactTypeId?: IntWithAggregatesFilter<"Contact"> | number
    name?: StringWithAggregatesFilter<"Contact"> | string
    department?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    street?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    city?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    website?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    description?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isActive?: BoolWithAggregatesFilter<"Contact"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Contact"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type DataVersionWhereInput = {
    AND?: DataVersionWhereInput | DataVersionWhereInput[]
    OR?: DataVersionWhereInput[]
    NOT?: DataVersionWhereInput | DataVersionWhereInput[]
    id?: IntFilter<"DataVersion"> | number
    tableName?: StringFilter<"DataVersion"> | string
    version?: IntFilter<"DataVersion"> | number
    lastUpdated?: DateTimeFilter<"DataVersion"> | Date | string
  }

  export type DataVersionOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    version?: SortOrder
    lastUpdated?: SortOrder
    _relevance?: DataVersionOrderByRelevanceInput
  }

  export type DataVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tableName?: string
    AND?: DataVersionWhereInput | DataVersionWhereInput[]
    OR?: DataVersionWhereInput[]
    NOT?: DataVersionWhereInput | DataVersionWhereInput[]
    version?: IntFilter<"DataVersion"> | number
    lastUpdated?: DateTimeFilter<"DataVersion"> | Date | string
  }, "id" | "tableName">

  export type DataVersionOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    version?: SortOrder
    lastUpdated?: SortOrder
    _count?: DataVersionCountOrderByAggregateInput
    _avg?: DataVersionAvgOrderByAggregateInput
    _max?: DataVersionMaxOrderByAggregateInput
    _min?: DataVersionMinOrderByAggregateInput
    _sum?: DataVersionSumOrderByAggregateInput
  }

  export type DataVersionScalarWhereWithAggregatesInput = {
    AND?: DataVersionScalarWhereWithAggregatesInput | DataVersionScalarWhereWithAggregatesInput[]
    OR?: DataVersionScalarWhereWithAggregatesInput[]
    NOT?: DataVersionScalarWhereWithAggregatesInput | DataVersionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DataVersion"> | number
    tableName?: StringWithAggregatesFilter<"DataVersion"> | string
    version?: IntWithAggregatesFilter<"DataVersion"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"DataVersion"> | Date | string
  }

  export type CantonCreateInput = {
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationCreateNestedManyWithoutCantonInput
    contacts?: ContactCreateNestedManyWithoutCantonInput
    calculationParams?: CalculationParameterCreateNestedManyWithoutCantonInput
    examples?: ExampleCreateNestedManyWithoutCantonInput
  }

  export type CantonUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationUncheckedCreateNestedManyWithoutCantonInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCantonInput
    calculationParams?: CalculationParameterUncheckedCreateNestedManyWithoutCantonInput
    examples?: ExampleUncheckedCreateNestedManyWithoutCantonInput
  }

  export type CantonUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUpdateManyWithoutCantonNestedInput
    contacts?: ContactUpdateManyWithoutCantonNestedInput
    calculationParams?: CalculationParameterUpdateManyWithoutCantonNestedInput
    examples?: ExampleUpdateManyWithoutCantonNestedInput
  }

  export type CantonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUncheckedUpdateManyWithoutCantonNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCantonNestedInput
    calculationParams?: CalculationParameterUncheckedUpdateManyWithoutCantonNestedInput
    examples?: ExampleUncheckedUpdateManyWithoutCantonNestedInput
  }

  export type CantonCreateManyInput = {
    id?: number
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CantonUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CantonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationCategoryCreateInput = {
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationCreateNestedManyWithoutCategoryInput
  }

  export type RegulationCategoryUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type RegulationCategoryUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUpdateManyWithoutCategoryNestedInput
  }

  export type RegulationCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type RegulationCategoryCreateManyInput = {
    id?: number
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegulationCategoryUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationCreateInput = {
    title: string
    summary: string
    content: string
    legalReference?: string | null
    sourceUrl?: string | null
    effectiveDate?: Date | string | null
    isActive?: boolean
    version?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    canton: CantonCreateNestedOneWithoutRegulationsInput
    category: RegulationCategoryCreateNestedOneWithoutRegulationsInput
  }

  export type RegulationUncheckedCreateInput = {
    id?: number
    cantonId: number
    categoryId: number
    title: string
    summary: string
    content: string
    legalReference?: string | null
    sourceUrl?: string | null
    effectiveDate?: Date | string | null
    isActive?: boolean
    version?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegulationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canton?: CantonUpdateOneRequiredWithoutRegulationsNestedInput
    category?: RegulationCategoryUpdateOneRequiredWithoutRegulationsNestedInput
  }

  export type RegulationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationCreateManyInput = {
    id?: number
    cantonId: number
    categoryId: number
    title: string
    summary: string
    content: string
    legalReference?: string | null
    sourceUrl?: string | null
    effectiveDate?: Date | string | null
    isActive?: boolean
    version?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegulationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationTypeCreateInput = {
    slug: string
    name: string
    description?: string | null
    formula?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: CalculationParameterCreateNestedManyWithoutCalculationTypeInput
  }

  export type CalculationTypeUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    description?: string | null
    formula?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parameters?: CalculationParameterUncheckedCreateNestedManyWithoutCalculationTypeInput
  }

  export type CalculationTypeUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: CalculationParameterUpdateManyWithoutCalculationTypeNestedInput
  }

  export type CalculationTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: CalculationParameterUncheckedUpdateManyWithoutCalculationTypeNestedInput
  }

  export type CalculationTypeCreateManyInput = {
    id?: number
    slug: string
    name: string
    description?: string | null
    formula?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalculationTypeUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationParameterCreateInput = {
    parameterKey: string
    parameterValue: string
    valueType?: $Enums.ValueType
    unit?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationType: CalculationTypeCreateNestedOneWithoutParametersInput
    canton?: CantonCreateNestedOneWithoutCalculationParamsInput
  }

  export type CalculationParameterUncheckedCreateInput = {
    id?: number
    calculationTypeId: number
    cantonId?: number | null
    parameterKey: string
    parameterValue: string
    valueType?: $Enums.ValueType
    unit?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalculationParameterUpdateInput = {
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationType?: CalculationTypeUpdateOneRequiredWithoutParametersNestedInput
    canton?: CantonUpdateOneWithoutCalculationParamsNestedInput
  }

  export type CalculationParameterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    calculationTypeId?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationParameterCreateManyInput = {
    id?: number
    calculationTypeId: number
    cantonId?: number | null
    parameterKey: string
    parameterValue: string
    valueType?: $Enums.ValueType
    unit?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalculationParameterUpdateManyMutationInput = {
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationParameterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    calculationTypeId?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleCategoryCreateInput = {
    slug: string
    name: string
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examples?: ExampleCreateNestedManyWithoutCategoryInput
  }

  export type ExampleCategoryUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    examples?: ExampleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExampleCategoryUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examples?: ExampleUpdateManyWithoutCategoryNestedInput
  }

  export type ExampleCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examples?: ExampleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExampleCategoryCreateManyInput = {
    id?: number
    slug: string
    name: string
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleCategoryUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleCreateInput = {
    title: string
    description: string
    content: string
    eventType?: string | null
    capacity?: number | null
    imageUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ExampleCategoryCreateNestedOneWithoutExamplesInput
    canton?: CantonCreateNestedOneWithoutExamplesInput
  }

  export type ExampleUncheckedCreateInput = {
    id?: number
    categoryId: number
    cantonId?: number | null
    title: string
    description: string
    content: string
    eventType?: string | null
    capacity?: number | null
    imageUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ExampleCategoryUpdateOneRequiredWithoutExamplesNestedInput
    canton?: CantonUpdateOneWithoutExamplesNestedInput
  }

  export type ExampleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleCreateManyInput = {
    id?: number
    categoryId: number
    cantonId?: number | null
    title: string
    description: string
    content: string
    eventType?: string | null
    capacity?: number | null
    imageUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTypeCreateInput = {
    slug: string
    name: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutContactTypeInput
  }

  export type ContactTypeUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutContactTypeInput
  }

  export type ContactTypeUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutContactTypeNestedInput
  }

  export type ContactTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutContactTypeNestedInput
  }

  export type ContactTypeCreateManyInput = {
    id?: number
    slug: string
    name: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTypeUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    name: string
    department?: string | null
    street?: string | null
    postalCode?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    canton?: CantonCreateNestedOneWithoutContactsInput
    contactType: ContactTypeCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: number
    cantonId?: number | null
    contactTypeId: number
    name: string
    department?: string | null
    street?: string | null
    postalCode?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canton?: CantonUpdateOneWithoutContactsNestedInput
    contactType?: ContactTypeUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    contactTypeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyInput = {
    id?: number
    cantonId?: number | null
    contactTypeId: number
    name: string
    department?: string | null
    street?: string | null
    postalCode?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    contactTypeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataVersionCreateInput = {
    tableName: string
    version?: number
    lastUpdated?: Date | string
  }

  export type DataVersionUncheckedCreateInput = {
    id?: number
    tableName: string
    version?: number
    lastUpdated?: Date | string
  }

  export type DataVersionUpdateInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataVersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataVersionCreateManyInput = {
    id?: number
    tableName: string
    version?: number
    lastUpdated?: Date | string
  }

  export type DataVersionUpdateManyMutationInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataVersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumCantonLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.CantonLanguage | EnumCantonLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.CantonLanguage[]
    notIn?: $Enums.CantonLanguage[]
    not?: NestedEnumCantonLanguageFilter<$PrismaModel> | $Enums.CantonLanguage
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RegulationListRelationFilter = {
    every?: RegulationWhereInput
    some?: RegulationWhereInput
    none?: RegulationWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type CalculationParameterListRelationFilter = {
    every?: CalculationParameterWhereInput
    some?: CalculationParameterWhereInput
    none?: CalculationParameterWhereInput
  }

  export type ExampleListRelationFilter = {
    every?: ExampleWhereInput
    some?: ExampleWhereInput
    none?: ExampleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RegulationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalculationParameterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExampleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CantonOrderByRelevanceInput = {
    fields: CantonOrderByRelevanceFieldEnum | CantonOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CantonCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameOfficial?: SortOrder
    coatOfArms?: SortOrder
    language?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CantonAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type CantonMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameOfficial?: SortOrder
    coatOfArms?: SortOrder
    language?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CantonMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameOfficial?: SortOrder
    coatOfArms?: SortOrder
    language?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CantonSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumCantonLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CantonLanguage | EnumCantonLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.CantonLanguage[]
    notIn?: $Enums.CantonLanguage[]
    not?: NestedEnumCantonLanguageWithAggregatesFilter<$PrismaModel> | $Enums.CantonLanguage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCantonLanguageFilter<$PrismaModel>
    _max?: NestedEnumCantonLanguageFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type RegulationCategoryOrderByRelevanceInput = {
    fields: RegulationCategoryOrderByRelevanceFieldEnum | RegulationCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RegulationCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegulationCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type RegulationCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegulationCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegulationCategorySumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CantonScalarRelationFilter = {
    is?: CantonWhereInput
    isNot?: CantonWhereInput
  }

  export type RegulationCategoryScalarRelationFilter = {
    is?: RegulationCategoryWhereInput
    isNot?: RegulationCategoryWhereInput
  }

  export type RegulationOrderByRelevanceInput = {
    fields: RegulationOrderByRelevanceFieldEnum | RegulationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RegulationCountOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    legalReference?: SortOrder
    sourceUrl?: SortOrder
    effectiveDate?: SortOrder
    isActive?: SortOrder
    version?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegulationAvgOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    categoryId?: SortOrder
    version?: SortOrder
    sortOrder?: SortOrder
  }

  export type RegulationMaxOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    legalReference?: SortOrder
    sourceUrl?: SortOrder
    effectiveDate?: SortOrder
    isActive?: SortOrder
    version?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegulationMinOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    content?: SortOrder
    legalReference?: SortOrder
    sourceUrl?: SortOrder
    effectiveDate?: SortOrder
    isActive?: SortOrder
    version?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegulationSumOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    categoryId?: SortOrder
    version?: SortOrder
    sortOrder?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CalculationTypeOrderByRelevanceInput = {
    fields: CalculationTypeOrderByRelevanceFieldEnum | CalculationTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CalculationTypeCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    formula?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalculationTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type CalculationTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    formula?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalculationTypeMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    formula?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalculationTypeSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumValueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ValueType | EnumValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ValueType[]
    notIn?: $Enums.ValueType[]
    not?: NestedEnumValueTypeFilter<$PrismaModel> | $Enums.ValueType
  }

  export type CalculationTypeScalarRelationFilter = {
    is?: CalculationTypeWhereInput
    isNot?: CalculationTypeWhereInput
  }

  export type CantonNullableScalarRelationFilter = {
    is?: CantonWhereInput | null
    isNot?: CantonWhereInput | null
  }

  export type CalculationParameterOrderByRelevanceInput = {
    fields: CalculationParameterOrderByRelevanceFieldEnum | CalculationParameterOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CalculationParameterCalculationTypeIdCantonIdParameterKeyCompoundUniqueInput = {
    calculationTypeId: number
    cantonId: number
    parameterKey: string
  }

  export type CalculationParameterCountOrderByAggregateInput = {
    id?: SortOrder
    calculationTypeId?: SortOrder
    cantonId?: SortOrder
    parameterKey?: SortOrder
    parameterValue?: SortOrder
    valueType?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalculationParameterAvgOrderByAggregateInput = {
    id?: SortOrder
    calculationTypeId?: SortOrder
    cantonId?: SortOrder
  }

  export type CalculationParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    calculationTypeId?: SortOrder
    cantonId?: SortOrder
    parameterKey?: SortOrder
    parameterValue?: SortOrder
    valueType?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalculationParameterMinOrderByAggregateInput = {
    id?: SortOrder
    calculationTypeId?: SortOrder
    cantonId?: SortOrder
    parameterKey?: SortOrder
    parameterValue?: SortOrder
    valueType?: SortOrder
    unit?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalculationParameterSumOrderByAggregateInput = {
    id?: SortOrder
    calculationTypeId?: SortOrder
    cantonId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumValueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ValueType | EnumValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ValueType[]
    notIn?: $Enums.ValueType[]
    not?: NestedEnumValueTypeWithAggregatesFilter<$PrismaModel> | $Enums.ValueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValueTypeFilter<$PrismaModel>
    _max?: NestedEnumValueTypeFilter<$PrismaModel>
  }

  export type ExampleCategoryOrderByRelevanceInput = {
    fields: ExampleCategoryOrderByRelevanceFieldEnum | ExampleCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExampleCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExampleCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type ExampleCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExampleCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExampleCategorySumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type ExampleCategoryScalarRelationFilter = {
    is?: ExampleCategoryWhereInput
    isNot?: ExampleCategoryWhereInput
  }

  export type ExampleOrderByRelevanceInput = {
    fields: ExampleOrderByRelevanceFieldEnum | ExampleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExampleCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    cantonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    eventType?: SortOrder
    capacity?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExampleAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    cantonId?: SortOrder
    capacity?: SortOrder
    sortOrder?: SortOrder
  }

  export type ExampleMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    cantonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    eventType?: SortOrder
    capacity?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExampleMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    cantonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    eventType?: SortOrder
    capacity?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExampleSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    cantonId?: SortOrder
    capacity?: SortOrder
    sortOrder?: SortOrder
  }

  export type ContactTypeOrderByRelevanceInput = {
    fields: ContactTypeOrderByRelevanceFieldEnum | ContactTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactTypeCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type ContactTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactTypeMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactTypeSumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type ContactTypeScalarRelationFilter = {
    is?: ContactTypeWhereInput
    isNot?: ContactTypeWhereInput
  }

  export type ContactOrderByRelevanceInput = {
    fields: ContactOrderByRelevanceFieldEnum | ContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    contactTypeId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    street?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    contactTypeId?: SortOrder
    sortOrder?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    contactTypeId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    street?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    contactTypeId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    street?: SortOrder
    postalCode?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    id?: SortOrder
    cantonId?: SortOrder
    contactTypeId?: SortOrder
    sortOrder?: SortOrder
  }

  export type DataVersionOrderByRelevanceInput = {
    fields: DataVersionOrderByRelevanceFieldEnum | DataVersionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DataVersionCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    version?: SortOrder
    lastUpdated?: SortOrder
  }

  export type DataVersionAvgOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
  }

  export type DataVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    version?: SortOrder
    lastUpdated?: SortOrder
  }

  export type DataVersionMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    version?: SortOrder
    lastUpdated?: SortOrder
  }

  export type DataVersionSumOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
  }

  export type RegulationCreateNestedManyWithoutCantonInput = {
    create?: XOR<RegulationCreateWithoutCantonInput, RegulationUncheckedCreateWithoutCantonInput> | RegulationCreateWithoutCantonInput[] | RegulationUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: RegulationCreateOrConnectWithoutCantonInput | RegulationCreateOrConnectWithoutCantonInput[]
    createMany?: RegulationCreateManyCantonInputEnvelope
    connect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCantonInput = {
    create?: XOR<ContactCreateWithoutCantonInput, ContactUncheckedCreateWithoutCantonInput> | ContactCreateWithoutCantonInput[] | ContactUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCantonInput | ContactCreateOrConnectWithoutCantonInput[]
    createMany?: ContactCreateManyCantonInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type CalculationParameterCreateNestedManyWithoutCantonInput = {
    create?: XOR<CalculationParameterCreateWithoutCantonInput, CalculationParameterUncheckedCreateWithoutCantonInput> | CalculationParameterCreateWithoutCantonInput[] | CalculationParameterUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: CalculationParameterCreateOrConnectWithoutCantonInput | CalculationParameterCreateOrConnectWithoutCantonInput[]
    createMany?: CalculationParameterCreateManyCantonInputEnvelope
    connect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
  }

  export type ExampleCreateNestedManyWithoutCantonInput = {
    create?: XOR<ExampleCreateWithoutCantonInput, ExampleUncheckedCreateWithoutCantonInput> | ExampleCreateWithoutCantonInput[] | ExampleUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: ExampleCreateOrConnectWithoutCantonInput | ExampleCreateOrConnectWithoutCantonInput[]
    createMany?: ExampleCreateManyCantonInputEnvelope
    connect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
  }

  export type RegulationUncheckedCreateNestedManyWithoutCantonInput = {
    create?: XOR<RegulationCreateWithoutCantonInput, RegulationUncheckedCreateWithoutCantonInput> | RegulationCreateWithoutCantonInput[] | RegulationUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: RegulationCreateOrConnectWithoutCantonInput | RegulationCreateOrConnectWithoutCantonInput[]
    createMany?: RegulationCreateManyCantonInputEnvelope
    connect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCantonInput = {
    create?: XOR<ContactCreateWithoutCantonInput, ContactUncheckedCreateWithoutCantonInput> | ContactCreateWithoutCantonInput[] | ContactUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCantonInput | ContactCreateOrConnectWithoutCantonInput[]
    createMany?: ContactCreateManyCantonInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type CalculationParameterUncheckedCreateNestedManyWithoutCantonInput = {
    create?: XOR<CalculationParameterCreateWithoutCantonInput, CalculationParameterUncheckedCreateWithoutCantonInput> | CalculationParameterCreateWithoutCantonInput[] | CalculationParameterUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: CalculationParameterCreateOrConnectWithoutCantonInput | CalculationParameterCreateOrConnectWithoutCantonInput[]
    createMany?: CalculationParameterCreateManyCantonInputEnvelope
    connect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
  }

  export type ExampleUncheckedCreateNestedManyWithoutCantonInput = {
    create?: XOR<ExampleCreateWithoutCantonInput, ExampleUncheckedCreateWithoutCantonInput> | ExampleCreateWithoutCantonInput[] | ExampleUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: ExampleCreateOrConnectWithoutCantonInput | ExampleCreateOrConnectWithoutCantonInput[]
    createMany?: ExampleCreateManyCantonInputEnvelope
    connect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumCantonLanguageFieldUpdateOperationsInput = {
    set?: $Enums.CantonLanguage
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RegulationUpdateManyWithoutCantonNestedInput = {
    create?: XOR<RegulationCreateWithoutCantonInput, RegulationUncheckedCreateWithoutCantonInput> | RegulationCreateWithoutCantonInput[] | RegulationUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: RegulationCreateOrConnectWithoutCantonInput | RegulationCreateOrConnectWithoutCantonInput[]
    upsert?: RegulationUpsertWithWhereUniqueWithoutCantonInput | RegulationUpsertWithWhereUniqueWithoutCantonInput[]
    createMany?: RegulationCreateManyCantonInputEnvelope
    set?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    disconnect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    delete?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    connect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    update?: RegulationUpdateWithWhereUniqueWithoutCantonInput | RegulationUpdateWithWhereUniqueWithoutCantonInput[]
    updateMany?: RegulationUpdateManyWithWhereWithoutCantonInput | RegulationUpdateManyWithWhereWithoutCantonInput[]
    deleteMany?: RegulationScalarWhereInput | RegulationScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCantonNestedInput = {
    create?: XOR<ContactCreateWithoutCantonInput, ContactUncheckedCreateWithoutCantonInput> | ContactCreateWithoutCantonInput[] | ContactUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCantonInput | ContactCreateOrConnectWithoutCantonInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCantonInput | ContactUpsertWithWhereUniqueWithoutCantonInput[]
    createMany?: ContactCreateManyCantonInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCantonInput | ContactUpdateWithWhereUniqueWithoutCantonInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCantonInput | ContactUpdateManyWithWhereWithoutCantonInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CalculationParameterUpdateManyWithoutCantonNestedInput = {
    create?: XOR<CalculationParameterCreateWithoutCantonInput, CalculationParameterUncheckedCreateWithoutCantonInput> | CalculationParameterCreateWithoutCantonInput[] | CalculationParameterUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: CalculationParameterCreateOrConnectWithoutCantonInput | CalculationParameterCreateOrConnectWithoutCantonInput[]
    upsert?: CalculationParameterUpsertWithWhereUniqueWithoutCantonInput | CalculationParameterUpsertWithWhereUniqueWithoutCantonInput[]
    createMany?: CalculationParameterCreateManyCantonInputEnvelope
    set?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    disconnect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    delete?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    connect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    update?: CalculationParameterUpdateWithWhereUniqueWithoutCantonInput | CalculationParameterUpdateWithWhereUniqueWithoutCantonInput[]
    updateMany?: CalculationParameterUpdateManyWithWhereWithoutCantonInput | CalculationParameterUpdateManyWithWhereWithoutCantonInput[]
    deleteMany?: CalculationParameterScalarWhereInput | CalculationParameterScalarWhereInput[]
  }

  export type ExampleUpdateManyWithoutCantonNestedInput = {
    create?: XOR<ExampleCreateWithoutCantonInput, ExampleUncheckedCreateWithoutCantonInput> | ExampleCreateWithoutCantonInput[] | ExampleUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: ExampleCreateOrConnectWithoutCantonInput | ExampleCreateOrConnectWithoutCantonInput[]
    upsert?: ExampleUpsertWithWhereUniqueWithoutCantonInput | ExampleUpsertWithWhereUniqueWithoutCantonInput[]
    createMany?: ExampleCreateManyCantonInputEnvelope
    set?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    disconnect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    delete?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    connect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    update?: ExampleUpdateWithWhereUniqueWithoutCantonInput | ExampleUpdateWithWhereUniqueWithoutCantonInput[]
    updateMany?: ExampleUpdateManyWithWhereWithoutCantonInput | ExampleUpdateManyWithWhereWithoutCantonInput[]
    deleteMany?: ExampleScalarWhereInput | ExampleScalarWhereInput[]
  }

  export type RegulationUncheckedUpdateManyWithoutCantonNestedInput = {
    create?: XOR<RegulationCreateWithoutCantonInput, RegulationUncheckedCreateWithoutCantonInput> | RegulationCreateWithoutCantonInput[] | RegulationUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: RegulationCreateOrConnectWithoutCantonInput | RegulationCreateOrConnectWithoutCantonInput[]
    upsert?: RegulationUpsertWithWhereUniqueWithoutCantonInput | RegulationUpsertWithWhereUniqueWithoutCantonInput[]
    createMany?: RegulationCreateManyCantonInputEnvelope
    set?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    disconnect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    delete?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    connect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    update?: RegulationUpdateWithWhereUniqueWithoutCantonInput | RegulationUpdateWithWhereUniqueWithoutCantonInput[]
    updateMany?: RegulationUpdateManyWithWhereWithoutCantonInput | RegulationUpdateManyWithWhereWithoutCantonInput[]
    deleteMany?: RegulationScalarWhereInput | RegulationScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCantonNestedInput = {
    create?: XOR<ContactCreateWithoutCantonInput, ContactUncheckedCreateWithoutCantonInput> | ContactCreateWithoutCantonInput[] | ContactUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCantonInput | ContactCreateOrConnectWithoutCantonInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCantonInput | ContactUpsertWithWhereUniqueWithoutCantonInput[]
    createMany?: ContactCreateManyCantonInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCantonInput | ContactUpdateWithWhereUniqueWithoutCantonInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCantonInput | ContactUpdateManyWithWhereWithoutCantonInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CalculationParameterUncheckedUpdateManyWithoutCantonNestedInput = {
    create?: XOR<CalculationParameterCreateWithoutCantonInput, CalculationParameterUncheckedCreateWithoutCantonInput> | CalculationParameterCreateWithoutCantonInput[] | CalculationParameterUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: CalculationParameterCreateOrConnectWithoutCantonInput | CalculationParameterCreateOrConnectWithoutCantonInput[]
    upsert?: CalculationParameterUpsertWithWhereUniqueWithoutCantonInput | CalculationParameterUpsertWithWhereUniqueWithoutCantonInput[]
    createMany?: CalculationParameterCreateManyCantonInputEnvelope
    set?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    disconnect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    delete?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    connect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    update?: CalculationParameterUpdateWithWhereUniqueWithoutCantonInput | CalculationParameterUpdateWithWhereUniqueWithoutCantonInput[]
    updateMany?: CalculationParameterUpdateManyWithWhereWithoutCantonInput | CalculationParameterUpdateManyWithWhereWithoutCantonInput[]
    deleteMany?: CalculationParameterScalarWhereInput | CalculationParameterScalarWhereInput[]
  }

  export type ExampleUncheckedUpdateManyWithoutCantonNestedInput = {
    create?: XOR<ExampleCreateWithoutCantonInput, ExampleUncheckedCreateWithoutCantonInput> | ExampleCreateWithoutCantonInput[] | ExampleUncheckedCreateWithoutCantonInput[]
    connectOrCreate?: ExampleCreateOrConnectWithoutCantonInput | ExampleCreateOrConnectWithoutCantonInput[]
    upsert?: ExampleUpsertWithWhereUniqueWithoutCantonInput | ExampleUpsertWithWhereUniqueWithoutCantonInput[]
    createMany?: ExampleCreateManyCantonInputEnvelope
    set?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    disconnect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    delete?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    connect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    update?: ExampleUpdateWithWhereUniqueWithoutCantonInput | ExampleUpdateWithWhereUniqueWithoutCantonInput[]
    updateMany?: ExampleUpdateManyWithWhereWithoutCantonInput | ExampleUpdateManyWithWhereWithoutCantonInput[]
    deleteMany?: ExampleScalarWhereInput | ExampleScalarWhereInput[]
  }

  export type RegulationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RegulationCreateWithoutCategoryInput, RegulationUncheckedCreateWithoutCategoryInput> | RegulationCreateWithoutCategoryInput[] | RegulationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RegulationCreateOrConnectWithoutCategoryInput | RegulationCreateOrConnectWithoutCategoryInput[]
    createMany?: RegulationCreateManyCategoryInputEnvelope
    connect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
  }

  export type RegulationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<RegulationCreateWithoutCategoryInput, RegulationUncheckedCreateWithoutCategoryInput> | RegulationCreateWithoutCategoryInput[] | RegulationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RegulationCreateOrConnectWithoutCategoryInput | RegulationCreateOrConnectWithoutCategoryInput[]
    createMany?: RegulationCreateManyCategoryInputEnvelope
    connect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
  }

  export type RegulationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RegulationCreateWithoutCategoryInput, RegulationUncheckedCreateWithoutCategoryInput> | RegulationCreateWithoutCategoryInput[] | RegulationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RegulationCreateOrConnectWithoutCategoryInput | RegulationCreateOrConnectWithoutCategoryInput[]
    upsert?: RegulationUpsertWithWhereUniqueWithoutCategoryInput | RegulationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RegulationCreateManyCategoryInputEnvelope
    set?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    disconnect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    delete?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    connect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    update?: RegulationUpdateWithWhereUniqueWithoutCategoryInput | RegulationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RegulationUpdateManyWithWhereWithoutCategoryInput | RegulationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RegulationScalarWhereInput | RegulationScalarWhereInput[]
  }

  export type RegulationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<RegulationCreateWithoutCategoryInput, RegulationUncheckedCreateWithoutCategoryInput> | RegulationCreateWithoutCategoryInput[] | RegulationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: RegulationCreateOrConnectWithoutCategoryInput | RegulationCreateOrConnectWithoutCategoryInput[]
    upsert?: RegulationUpsertWithWhereUniqueWithoutCategoryInput | RegulationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: RegulationCreateManyCategoryInputEnvelope
    set?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    disconnect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    delete?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    connect?: RegulationWhereUniqueInput | RegulationWhereUniqueInput[]
    update?: RegulationUpdateWithWhereUniqueWithoutCategoryInput | RegulationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: RegulationUpdateManyWithWhereWithoutCategoryInput | RegulationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: RegulationScalarWhereInput | RegulationScalarWhereInput[]
  }

  export type CantonCreateNestedOneWithoutRegulationsInput = {
    create?: XOR<CantonCreateWithoutRegulationsInput, CantonUncheckedCreateWithoutRegulationsInput>
    connectOrCreate?: CantonCreateOrConnectWithoutRegulationsInput
    connect?: CantonWhereUniqueInput
  }

  export type RegulationCategoryCreateNestedOneWithoutRegulationsInput = {
    create?: XOR<RegulationCategoryCreateWithoutRegulationsInput, RegulationCategoryUncheckedCreateWithoutRegulationsInput>
    connectOrCreate?: RegulationCategoryCreateOrConnectWithoutRegulationsInput
    connect?: RegulationCategoryWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CantonUpdateOneRequiredWithoutRegulationsNestedInput = {
    create?: XOR<CantonCreateWithoutRegulationsInput, CantonUncheckedCreateWithoutRegulationsInput>
    connectOrCreate?: CantonCreateOrConnectWithoutRegulationsInput
    upsert?: CantonUpsertWithoutRegulationsInput
    connect?: CantonWhereUniqueInput
    update?: XOR<XOR<CantonUpdateToOneWithWhereWithoutRegulationsInput, CantonUpdateWithoutRegulationsInput>, CantonUncheckedUpdateWithoutRegulationsInput>
  }

  export type RegulationCategoryUpdateOneRequiredWithoutRegulationsNestedInput = {
    create?: XOR<RegulationCategoryCreateWithoutRegulationsInput, RegulationCategoryUncheckedCreateWithoutRegulationsInput>
    connectOrCreate?: RegulationCategoryCreateOrConnectWithoutRegulationsInput
    upsert?: RegulationCategoryUpsertWithoutRegulationsInput
    connect?: RegulationCategoryWhereUniqueInput
    update?: XOR<XOR<RegulationCategoryUpdateToOneWithWhereWithoutRegulationsInput, RegulationCategoryUpdateWithoutRegulationsInput>, RegulationCategoryUncheckedUpdateWithoutRegulationsInput>
  }

  export type CalculationParameterCreateNestedManyWithoutCalculationTypeInput = {
    create?: XOR<CalculationParameterCreateWithoutCalculationTypeInput, CalculationParameterUncheckedCreateWithoutCalculationTypeInput> | CalculationParameterCreateWithoutCalculationTypeInput[] | CalculationParameterUncheckedCreateWithoutCalculationTypeInput[]
    connectOrCreate?: CalculationParameterCreateOrConnectWithoutCalculationTypeInput | CalculationParameterCreateOrConnectWithoutCalculationTypeInput[]
    createMany?: CalculationParameterCreateManyCalculationTypeInputEnvelope
    connect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
  }

  export type CalculationParameterUncheckedCreateNestedManyWithoutCalculationTypeInput = {
    create?: XOR<CalculationParameterCreateWithoutCalculationTypeInput, CalculationParameterUncheckedCreateWithoutCalculationTypeInput> | CalculationParameterCreateWithoutCalculationTypeInput[] | CalculationParameterUncheckedCreateWithoutCalculationTypeInput[]
    connectOrCreate?: CalculationParameterCreateOrConnectWithoutCalculationTypeInput | CalculationParameterCreateOrConnectWithoutCalculationTypeInput[]
    createMany?: CalculationParameterCreateManyCalculationTypeInputEnvelope
    connect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
  }

  export type CalculationParameterUpdateManyWithoutCalculationTypeNestedInput = {
    create?: XOR<CalculationParameterCreateWithoutCalculationTypeInput, CalculationParameterUncheckedCreateWithoutCalculationTypeInput> | CalculationParameterCreateWithoutCalculationTypeInput[] | CalculationParameterUncheckedCreateWithoutCalculationTypeInput[]
    connectOrCreate?: CalculationParameterCreateOrConnectWithoutCalculationTypeInput | CalculationParameterCreateOrConnectWithoutCalculationTypeInput[]
    upsert?: CalculationParameterUpsertWithWhereUniqueWithoutCalculationTypeInput | CalculationParameterUpsertWithWhereUniqueWithoutCalculationTypeInput[]
    createMany?: CalculationParameterCreateManyCalculationTypeInputEnvelope
    set?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    disconnect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    delete?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    connect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    update?: CalculationParameterUpdateWithWhereUniqueWithoutCalculationTypeInput | CalculationParameterUpdateWithWhereUniqueWithoutCalculationTypeInput[]
    updateMany?: CalculationParameterUpdateManyWithWhereWithoutCalculationTypeInput | CalculationParameterUpdateManyWithWhereWithoutCalculationTypeInput[]
    deleteMany?: CalculationParameterScalarWhereInput | CalculationParameterScalarWhereInput[]
  }

  export type CalculationParameterUncheckedUpdateManyWithoutCalculationTypeNestedInput = {
    create?: XOR<CalculationParameterCreateWithoutCalculationTypeInput, CalculationParameterUncheckedCreateWithoutCalculationTypeInput> | CalculationParameterCreateWithoutCalculationTypeInput[] | CalculationParameterUncheckedCreateWithoutCalculationTypeInput[]
    connectOrCreate?: CalculationParameterCreateOrConnectWithoutCalculationTypeInput | CalculationParameterCreateOrConnectWithoutCalculationTypeInput[]
    upsert?: CalculationParameterUpsertWithWhereUniqueWithoutCalculationTypeInput | CalculationParameterUpsertWithWhereUniqueWithoutCalculationTypeInput[]
    createMany?: CalculationParameterCreateManyCalculationTypeInputEnvelope
    set?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    disconnect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    delete?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    connect?: CalculationParameterWhereUniqueInput | CalculationParameterWhereUniqueInput[]
    update?: CalculationParameterUpdateWithWhereUniqueWithoutCalculationTypeInput | CalculationParameterUpdateWithWhereUniqueWithoutCalculationTypeInput[]
    updateMany?: CalculationParameterUpdateManyWithWhereWithoutCalculationTypeInput | CalculationParameterUpdateManyWithWhereWithoutCalculationTypeInput[]
    deleteMany?: CalculationParameterScalarWhereInput | CalculationParameterScalarWhereInput[]
  }

  export type CalculationTypeCreateNestedOneWithoutParametersInput = {
    create?: XOR<CalculationTypeCreateWithoutParametersInput, CalculationTypeUncheckedCreateWithoutParametersInput>
    connectOrCreate?: CalculationTypeCreateOrConnectWithoutParametersInput
    connect?: CalculationTypeWhereUniqueInput
  }

  export type CantonCreateNestedOneWithoutCalculationParamsInput = {
    create?: XOR<CantonCreateWithoutCalculationParamsInput, CantonUncheckedCreateWithoutCalculationParamsInput>
    connectOrCreate?: CantonCreateOrConnectWithoutCalculationParamsInput
    connect?: CantonWhereUniqueInput
  }

  export type EnumValueTypeFieldUpdateOperationsInput = {
    set?: $Enums.ValueType
  }

  export type CalculationTypeUpdateOneRequiredWithoutParametersNestedInput = {
    create?: XOR<CalculationTypeCreateWithoutParametersInput, CalculationTypeUncheckedCreateWithoutParametersInput>
    connectOrCreate?: CalculationTypeCreateOrConnectWithoutParametersInput
    upsert?: CalculationTypeUpsertWithoutParametersInput
    connect?: CalculationTypeWhereUniqueInput
    update?: XOR<XOR<CalculationTypeUpdateToOneWithWhereWithoutParametersInput, CalculationTypeUpdateWithoutParametersInput>, CalculationTypeUncheckedUpdateWithoutParametersInput>
  }

  export type CantonUpdateOneWithoutCalculationParamsNestedInput = {
    create?: XOR<CantonCreateWithoutCalculationParamsInput, CantonUncheckedCreateWithoutCalculationParamsInput>
    connectOrCreate?: CantonCreateOrConnectWithoutCalculationParamsInput
    upsert?: CantonUpsertWithoutCalculationParamsInput
    disconnect?: CantonWhereInput | boolean
    delete?: CantonWhereInput | boolean
    connect?: CantonWhereUniqueInput
    update?: XOR<XOR<CantonUpdateToOneWithWhereWithoutCalculationParamsInput, CantonUpdateWithoutCalculationParamsInput>, CantonUncheckedUpdateWithoutCalculationParamsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExampleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExampleCreateWithoutCategoryInput, ExampleUncheckedCreateWithoutCategoryInput> | ExampleCreateWithoutCategoryInput[] | ExampleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExampleCreateOrConnectWithoutCategoryInput | ExampleCreateOrConnectWithoutCategoryInput[]
    createMany?: ExampleCreateManyCategoryInputEnvelope
    connect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
  }

  export type ExampleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExampleCreateWithoutCategoryInput, ExampleUncheckedCreateWithoutCategoryInput> | ExampleCreateWithoutCategoryInput[] | ExampleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExampleCreateOrConnectWithoutCategoryInput | ExampleCreateOrConnectWithoutCategoryInput[]
    createMany?: ExampleCreateManyCategoryInputEnvelope
    connect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
  }

  export type ExampleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExampleCreateWithoutCategoryInput, ExampleUncheckedCreateWithoutCategoryInput> | ExampleCreateWithoutCategoryInput[] | ExampleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExampleCreateOrConnectWithoutCategoryInput | ExampleCreateOrConnectWithoutCategoryInput[]
    upsert?: ExampleUpsertWithWhereUniqueWithoutCategoryInput | ExampleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExampleCreateManyCategoryInputEnvelope
    set?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    disconnect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    delete?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    connect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    update?: ExampleUpdateWithWhereUniqueWithoutCategoryInput | ExampleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExampleUpdateManyWithWhereWithoutCategoryInput | ExampleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExampleScalarWhereInput | ExampleScalarWhereInput[]
  }

  export type ExampleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExampleCreateWithoutCategoryInput, ExampleUncheckedCreateWithoutCategoryInput> | ExampleCreateWithoutCategoryInput[] | ExampleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExampleCreateOrConnectWithoutCategoryInput | ExampleCreateOrConnectWithoutCategoryInput[]
    upsert?: ExampleUpsertWithWhereUniqueWithoutCategoryInput | ExampleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExampleCreateManyCategoryInputEnvelope
    set?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    disconnect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    delete?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    connect?: ExampleWhereUniqueInput | ExampleWhereUniqueInput[]
    update?: ExampleUpdateWithWhereUniqueWithoutCategoryInput | ExampleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExampleUpdateManyWithWhereWithoutCategoryInput | ExampleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExampleScalarWhereInput | ExampleScalarWhereInput[]
  }

  export type ExampleCategoryCreateNestedOneWithoutExamplesInput = {
    create?: XOR<ExampleCategoryCreateWithoutExamplesInput, ExampleCategoryUncheckedCreateWithoutExamplesInput>
    connectOrCreate?: ExampleCategoryCreateOrConnectWithoutExamplesInput
    connect?: ExampleCategoryWhereUniqueInput
  }

  export type CantonCreateNestedOneWithoutExamplesInput = {
    create?: XOR<CantonCreateWithoutExamplesInput, CantonUncheckedCreateWithoutExamplesInput>
    connectOrCreate?: CantonCreateOrConnectWithoutExamplesInput
    connect?: CantonWhereUniqueInput
  }

  export type ExampleCategoryUpdateOneRequiredWithoutExamplesNestedInput = {
    create?: XOR<ExampleCategoryCreateWithoutExamplesInput, ExampleCategoryUncheckedCreateWithoutExamplesInput>
    connectOrCreate?: ExampleCategoryCreateOrConnectWithoutExamplesInput
    upsert?: ExampleCategoryUpsertWithoutExamplesInput
    connect?: ExampleCategoryWhereUniqueInput
    update?: XOR<XOR<ExampleCategoryUpdateToOneWithWhereWithoutExamplesInput, ExampleCategoryUpdateWithoutExamplesInput>, ExampleCategoryUncheckedUpdateWithoutExamplesInput>
  }

  export type CantonUpdateOneWithoutExamplesNestedInput = {
    create?: XOR<CantonCreateWithoutExamplesInput, CantonUncheckedCreateWithoutExamplesInput>
    connectOrCreate?: CantonCreateOrConnectWithoutExamplesInput
    upsert?: CantonUpsertWithoutExamplesInput
    disconnect?: CantonWhereInput | boolean
    delete?: CantonWhereInput | boolean
    connect?: CantonWhereUniqueInput
    update?: XOR<XOR<CantonUpdateToOneWithWhereWithoutExamplesInput, CantonUpdateWithoutExamplesInput>, CantonUncheckedUpdateWithoutExamplesInput>
  }

  export type ContactCreateNestedManyWithoutContactTypeInput = {
    create?: XOR<ContactCreateWithoutContactTypeInput, ContactUncheckedCreateWithoutContactTypeInput> | ContactCreateWithoutContactTypeInput[] | ContactUncheckedCreateWithoutContactTypeInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutContactTypeInput | ContactCreateOrConnectWithoutContactTypeInput[]
    createMany?: ContactCreateManyContactTypeInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutContactTypeInput = {
    create?: XOR<ContactCreateWithoutContactTypeInput, ContactUncheckedCreateWithoutContactTypeInput> | ContactCreateWithoutContactTypeInput[] | ContactUncheckedCreateWithoutContactTypeInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutContactTypeInput | ContactCreateOrConnectWithoutContactTypeInput[]
    createMany?: ContactCreateManyContactTypeInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactUpdateManyWithoutContactTypeNestedInput = {
    create?: XOR<ContactCreateWithoutContactTypeInput, ContactUncheckedCreateWithoutContactTypeInput> | ContactCreateWithoutContactTypeInput[] | ContactUncheckedCreateWithoutContactTypeInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutContactTypeInput | ContactCreateOrConnectWithoutContactTypeInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutContactTypeInput | ContactUpsertWithWhereUniqueWithoutContactTypeInput[]
    createMany?: ContactCreateManyContactTypeInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutContactTypeInput | ContactUpdateWithWhereUniqueWithoutContactTypeInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutContactTypeInput | ContactUpdateManyWithWhereWithoutContactTypeInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutContactTypeNestedInput = {
    create?: XOR<ContactCreateWithoutContactTypeInput, ContactUncheckedCreateWithoutContactTypeInput> | ContactCreateWithoutContactTypeInput[] | ContactUncheckedCreateWithoutContactTypeInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutContactTypeInput | ContactCreateOrConnectWithoutContactTypeInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutContactTypeInput | ContactUpsertWithWhereUniqueWithoutContactTypeInput[]
    createMany?: ContactCreateManyContactTypeInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutContactTypeInput | ContactUpdateWithWhereUniqueWithoutContactTypeInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutContactTypeInput | ContactUpdateManyWithWhereWithoutContactTypeInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CantonCreateNestedOneWithoutContactsInput = {
    create?: XOR<CantonCreateWithoutContactsInput, CantonUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CantonCreateOrConnectWithoutContactsInput
    connect?: CantonWhereUniqueInput
  }

  export type ContactTypeCreateNestedOneWithoutContactsInput = {
    create?: XOR<ContactTypeCreateWithoutContactsInput, ContactTypeUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ContactTypeCreateOrConnectWithoutContactsInput
    connect?: ContactTypeWhereUniqueInput
  }

  export type CantonUpdateOneWithoutContactsNestedInput = {
    create?: XOR<CantonCreateWithoutContactsInput, CantonUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CantonCreateOrConnectWithoutContactsInput
    upsert?: CantonUpsertWithoutContactsInput
    disconnect?: CantonWhereInput | boolean
    delete?: CantonWhereInput | boolean
    connect?: CantonWhereUniqueInput
    update?: XOR<XOR<CantonUpdateToOneWithWhereWithoutContactsInput, CantonUpdateWithoutContactsInput>, CantonUncheckedUpdateWithoutContactsInput>
  }

  export type ContactTypeUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<ContactTypeCreateWithoutContactsInput, ContactTypeUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ContactTypeCreateOrConnectWithoutContactsInput
    upsert?: ContactTypeUpsertWithoutContactsInput
    connect?: ContactTypeWhereUniqueInput
    update?: XOR<XOR<ContactTypeUpdateToOneWithWhereWithoutContactsInput, ContactTypeUpdateWithoutContactsInput>, ContactTypeUncheckedUpdateWithoutContactsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumCantonLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.CantonLanguage | EnumCantonLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.CantonLanguage[]
    notIn?: $Enums.CantonLanguage[]
    not?: NestedEnumCantonLanguageFilter<$PrismaModel> | $Enums.CantonLanguage
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCantonLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CantonLanguage | EnumCantonLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.CantonLanguage[]
    notIn?: $Enums.CantonLanguage[]
    not?: NestedEnumCantonLanguageWithAggregatesFilter<$PrismaModel> | $Enums.CantonLanguage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCantonLanguageFilter<$PrismaModel>
    _max?: NestedEnumCantonLanguageFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumValueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ValueType | EnumValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ValueType[]
    notIn?: $Enums.ValueType[]
    not?: NestedEnumValueTypeFilter<$PrismaModel> | $Enums.ValueType
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumValueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ValueType | EnumValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ValueType[]
    notIn?: $Enums.ValueType[]
    not?: NestedEnumValueTypeWithAggregatesFilter<$PrismaModel> | $Enums.ValueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumValueTypeFilter<$PrismaModel>
    _max?: NestedEnumValueTypeFilter<$PrismaModel>
  }

  export type RegulationCreateWithoutCantonInput = {
    title: string
    summary: string
    content: string
    legalReference?: string | null
    sourceUrl?: string | null
    effectiveDate?: Date | string | null
    isActive?: boolean
    version?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: RegulationCategoryCreateNestedOneWithoutRegulationsInput
  }

  export type RegulationUncheckedCreateWithoutCantonInput = {
    id?: number
    categoryId: number
    title: string
    summary: string
    content: string
    legalReference?: string | null
    sourceUrl?: string | null
    effectiveDate?: Date | string | null
    isActive?: boolean
    version?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegulationCreateOrConnectWithoutCantonInput = {
    where: RegulationWhereUniqueInput
    create: XOR<RegulationCreateWithoutCantonInput, RegulationUncheckedCreateWithoutCantonInput>
  }

  export type RegulationCreateManyCantonInputEnvelope = {
    data: RegulationCreateManyCantonInput | RegulationCreateManyCantonInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutCantonInput = {
    name: string
    department?: string | null
    street?: string | null
    postalCode?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contactType: ContactTypeCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutCantonInput = {
    id?: number
    contactTypeId: number
    name: string
    department?: string | null
    street?: string | null
    postalCode?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutCantonInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCantonInput, ContactUncheckedCreateWithoutCantonInput>
  }

  export type ContactCreateManyCantonInputEnvelope = {
    data: ContactCreateManyCantonInput | ContactCreateManyCantonInput[]
    skipDuplicates?: boolean
  }

  export type CalculationParameterCreateWithoutCantonInput = {
    parameterKey: string
    parameterValue: string
    valueType?: $Enums.ValueType
    unit?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calculationType: CalculationTypeCreateNestedOneWithoutParametersInput
  }

  export type CalculationParameterUncheckedCreateWithoutCantonInput = {
    id?: number
    calculationTypeId: number
    parameterKey: string
    parameterValue: string
    valueType?: $Enums.ValueType
    unit?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalculationParameterCreateOrConnectWithoutCantonInput = {
    where: CalculationParameterWhereUniqueInput
    create: XOR<CalculationParameterCreateWithoutCantonInput, CalculationParameterUncheckedCreateWithoutCantonInput>
  }

  export type CalculationParameterCreateManyCantonInputEnvelope = {
    data: CalculationParameterCreateManyCantonInput | CalculationParameterCreateManyCantonInput[]
    skipDuplicates?: boolean
  }

  export type ExampleCreateWithoutCantonInput = {
    title: string
    description: string
    content: string
    eventType?: string | null
    capacity?: number | null
    imageUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: ExampleCategoryCreateNestedOneWithoutExamplesInput
  }

  export type ExampleUncheckedCreateWithoutCantonInput = {
    id?: number
    categoryId: number
    title: string
    description: string
    content: string
    eventType?: string | null
    capacity?: number | null
    imageUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleCreateOrConnectWithoutCantonInput = {
    where: ExampleWhereUniqueInput
    create: XOR<ExampleCreateWithoutCantonInput, ExampleUncheckedCreateWithoutCantonInput>
  }

  export type ExampleCreateManyCantonInputEnvelope = {
    data: ExampleCreateManyCantonInput | ExampleCreateManyCantonInput[]
    skipDuplicates?: boolean
  }

  export type RegulationUpsertWithWhereUniqueWithoutCantonInput = {
    where: RegulationWhereUniqueInput
    update: XOR<RegulationUpdateWithoutCantonInput, RegulationUncheckedUpdateWithoutCantonInput>
    create: XOR<RegulationCreateWithoutCantonInput, RegulationUncheckedCreateWithoutCantonInput>
  }

  export type RegulationUpdateWithWhereUniqueWithoutCantonInput = {
    where: RegulationWhereUniqueInput
    data: XOR<RegulationUpdateWithoutCantonInput, RegulationUncheckedUpdateWithoutCantonInput>
  }

  export type RegulationUpdateManyWithWhereWithoutCantonInput = {
    where: RegulationScalarWhereInput
    data: XOR<RegulationUpdateManyMutationInput, RegulationUncheckedUpdateManyWithoutCantonInput>
  }

  export type RegulationScalarWhereInput = {
    AND?: RegulationScalarWhereInput | RegulationScalarWhereInput[]
    OR?: RegulationScalarWhereInput[]
    NOT?: RegulationScalarWhereInput | RegulationScalarWhereInput[]
    id?: IntFilter<"Regulation"> | number
    cantonId?: IntFilter<"Regulation"> | number
    categoryId?: IntFilter<"Regulation"> | number
    title?: StringFilter<"Regulation"> | string
    summary?: StringFilter<"Regulation"> | string
    content?: StringFilter<"Regulation"> | string
    legalReference?: StringNullableFilter<"Regulation"> | string | null
    sourceUrl?: StringNullableFilter<"Regulation"> | string | null
    effectiveDate?: DateTimeNullableFilter<"Regulation"> | Date | string | null
    isActive?: BoolFilter<"Regulation"> | boolean
    version?: IntFilter<"Regulation"> | number
    sortOrder?: IntFilter<"Regulation"> | number
    createdAt?: DateTimeFilter<"Regulation"> | Date | string
    updatedAt?: DateTimeFilter<"Regulation"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutCantonInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCantonInput, ContactUncheckedUpdateWithoutCantonInput>
    create: XOR<ContactCreateWithoutCantonInput, ContactUncheckedCreateWithoutCantonInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCantonInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCantonInput, ContactUncheckedUpdateWithoutCantonInput>
  }

  export type ContactUpdateManyWithWhereWithoutCantonInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCantonInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: IntFilter<"Contact"> | number
    cantonId?: IntNullableFilter<"Contact"> | number | null
    contactTypeId?: IntFilter<"Contact"> | number
    name?: StringFilter<"Contact"> | string
    department?: StringNullableFilter<"Contact"> | string | null
    street?: StringNullableFilter<"Contact"> | string | null
    postalCode?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    description?: StringNullableFilter<"Contact"> | string | null
    isActive?: BoolFilter<"Contact"> | boolean
    sortOrder?: IntFilter<"Contact"> | number
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type CalculationParameterUpsertWithWhereUniqueWithoutCantonInput = {
    where: CalculationParameterWhereUniqueInput
    update: XOR<CalculationParameterUpdateWithoutCantonInput, CalculationParameterUncheckedUpdateWithoutCantonInput>
    create: XOR<CalculationParameterCreateWithoutCantonInput, CalculationParameterUncheckedCreateWithoutCantonInput>
  }

  export type CalculationParameterUpdateWithWhereUniqueWithoutCantonInput = {
    where: CalculationParameterWhereUniqueInput
    data: XOR<CalculationParameterUpdateWithoutCantonInput, CalculationParameterUncheckedUpdateWithoutCantonInput>
  }

  export type CalculationParameterUpdateManyWithWhereWithoutCantonInput = {
    where: CalculationParameterScalarWhereInput
    data: XOR<CalculationParameterUpdateManyMutationInput, CalculationParameterUncheckedUpdateManyWithoutCantonInput>
  }

  export type CalculationParameterScalarWhereInput = {
    AND?: CalculationParameterScalarWhereInput | CalculationParameterScalarWhereInput[]
    OR?: CalculationParameterScalarWhereInput[]
    NOT?: CalculationParameterScalarWhereInput | CalculationParameterScalarWhereInput[]
    id?: IntFilter<"CalculationParameter"> | number
    calculationTypeId?: IntFilter<"CalculationParameter"> | number
    cantonId?: IntNullableFilter<"CalculationParameter"> | number | null
    parameterKey?: StringFilter<"CalculationParameter"> | string
    parameterValue?: StringFilter<"CalculationParameter"> | string
    valueType?: EnumValueTypeFilter<"CalculationParameter"> | $Enums.ValueType
    unit?: StringNullableFilter<"CalculationParameter"> | string | null
    description?: StringNullableFilter<"CalculationParameter"> | string | null
    createdAt?: DateTimeFilter<"CalculationParameter"> | Date | string
    updatedAt?: DateTimeFilter<"CalculationParameter"> | Date | string
  }

  export type ExampleUpsertWithWhereUniqueWithoutCantonInput = {
    where: ExampleWhereUniqueInput
    update: XOR<ExampleUpdateWithoutCantonInput, ExampleUncheckedUpdateWithoutCantonInput>
    create: XOR<ExampleCreateWithoutCantonInput, ExampleUncheckedCreateWithoutCantonInput>
  }

  export type ExampleUpdateWithWhereUniqueWithoutCantonInput = {
    where: ExampleWhereUniqueInput
    data: XOR<ExampleUpdateWithoutCantonInput, ExampleUncheckedUpdateWithoutCantonInput>
  }

  export type ExampleUpdateManyWithWhereWithoutCantonInput = {
    where: ExampleScalarWhereInput
    data: XOR<ExampleUpdateManyMutationInput, ExampleUncheckedUpdateManyWithoutCantonInput>
  }

  export type ExampleScalarWhereInput = {
    AND?: ExampleScalarWhereInput | ExampleScalarWhereInput[]
    OR?: ExampleScalarWhereInput[]
    NOT?: ExampleScalarWhereInput | ExampleScalarWhereInput[]
    id?: IntFilter<"Example"> | number
    categoryId?: IntFilter<"Example"> | number
    cantonId?: IntNullableFilter<"Example"> | number | null
    title?: StringFilter<"Example"> | string
    description?: StringFilter<"Example"> | string
    content?: StringFilter<"Example"> | string
    eventType?: StringNullableFilter<"Example"> | string | null
    capacity?: IntNullableFilter<"Example"> | number | null
    imageUrl?: StringNullableFilter<"Example"> | string | null
    isActive?: BoolFilter<"Example"> | boolean
    sortOrder?: IntFilter<"Example"> | number
    createdAt?: DateTimeFilter<"Example"> | Date | string
    updatedAt?: DateTimeFilter<"Example"> | Date | string
  }

  export type RegulationCreateWithoutCategoryInput = {
    title: string
    summary: string
    content: string
    legalReference?: string | null
    sourceUrl?: string | null
    effectiveDate?: Date | string | null
    isActive?: boolean
    version?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    canton: CantonCreateNestedOneWithoutRegulationsInput
  }

  export type RegulationUncheckedCreateWithoutCategoryInput = {
    id?: number
    cantonId: number
    title: string
    summary: string
    content: string
    legalReference?: string | null
    sourceUrl?: string | null
    effectiveDate?: Date | string | null
    isActive?: boolean
    version?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegulationCreateOrConnectWithoutCategoryInput = {
    where: RegulationWhereUniqueInput
    create: XOR<RegulationCreateWithoutCategoryInput, RegulationUncheckedCreateWithoutCategoryInput>
  }

  export type RegulationCreateManyCategoryInputEnvelope = {
    data: RegulationCreateManyCategoryInput | RegulationCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type RegulationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: RegulationWhereUniqueInput
    update: XOR<RegulationUpdateWithoutCategoryInput, RegulationUncheckedUpdateWithoutCategoryInput>
    create: XOR<RegulationCreateWithoutCategoryInput, RegulationUncheckedCreateWithoutCategoryInput>
  }

  export type RegulationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: RegulationWhereUniqueInput
    data: XOR<RegulationUpdateWithoutCategoryInput, RegulationUncheckedUpdateWithoutCategoryInput>
  }

  export type RegulationUpdateManyWithWhereWithoutCategoryInput = {
    where: RegulationScalarWhereInput
    data: XOR<RegulationUpdateManyMutationInput, RegulationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CantonCreateWithoutRegulationsInput = {
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCantonInput
    calculationParams?: CalculationParameterCreateNestedManyWithoutCantonInput
    examples?: ExampleCreateNestedManyWithoutCantonInput
  }

  export type CantonUncheckedCreateWithoutRegulationsInput = {
    id?: number
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCantonInput
    calculationParams?: CalculationParameterUncheckedCreateNestedManyWithoutCantonInput
    examples?: ExampleUncheckedCreateNestedManyWithoutCantonInput
  }

  export type CantonCreateOrConnectWithoutRegulationsInput = {
    where: CantonWhereUniqueInput
    create: XOR<CantonCreateWithoutRegulationsInput, CantonUncheckedCreateWithoutRegulationsInput>
  }

  export type RegulationCategoryCreateWithoutRegulationsInput = {
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegulationCategoryUncheckedCreateWithoutRegulationsInput = {
    id?: number
    slug: string
    name: string
    description?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegulationCategoryCreateOrConnectWithoutRegulationsInput = {
    where: RegulationCategoryWhereUniqueInput
    create: XOR<RegulationCategoryCreateWithoutRegulationsInput, RegulationCategoryUncheckedCreateWithoutRegulationsInput>
  }

  export type CantonUpsertWithoutRegulationsInput = {
    update: XOR<CantonUpdateWithoutRegulationsInput, CantonUncheckedUpdateWithoutRegulationsInput>
    create: XOR<CantonCreateWithoutRegulationsInput, CantonUncheckedCreateWithoutRegulationsInput>
    where?: CantonWhereInput
  }

  export type CantonUpdateToOneWithWhereWithoutRegulationsInput = {
    where?: CantonWhereInput
    data: XOR<CantonUpdateWithoutRegulationsInput, CantonUncheckedUpdateWithoutRegulationsInput>
  }

  export type CantonUpdateWithoutRegulationsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCantonNestedInput
    calculationParams?: CalculationParameterUpdateManyWithoutCantonNestedInput
    examples?: ExampleUpdateManyWithoutCantonNestedInput
  }

  export type CantonUncheckedUpdateWithoutRegulationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCantonNestedInput
    calculationParams?: CalculationParameterUncheckedUpdateManyWithoutCantonNestedInput
    examples?: ExampleUncheckedUpdateManyWithoutCantonNestedInput
  }

  export type RegulationCategoryUpsertWithoutRegulationsInput = {
    update: XOR<RegulationCategoryUpdateWithoutRegulationsInput, RegulationCategoryUncheckedUpdateWithoutRegulationsInput>
    create: XOR<RegulationCategoryCreateWithoutRegulationsInput, RegulationCategoryUncheckedCreateWithoutRegulationsInput>
    where?: RegulationCategoryWhereInput
  }

  export type RegulationCategoryUpdateToOneWithWhereWithoutRegulationsInput = {
    where?: RegulationCategoryWhereInput
    data: XOR<RegulationCategoryUpdateWithoutRegulationsInput, RegulationCategoryUncheckedUpdateWithoutRegulationsInput>
  }

  export type RegulationCategoryUpdateWithoutRegulationsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationCategoryUncheckedUpdateWithoutRegulationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationParameterCreateWithoutCalculationTypeInput = {
    parameterKey: string
    parameterValue: string
    valueType?: $Enums.ValueType
    unit?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    canton?: CantonCreateNestedOneWithoutCalculationParamsInput
  }

  export type CalculationParameterUncheckedCreateWithoutCalculationTypeInput = {
    id?: number
    cantonId?: number | null
    parameterKey: string
    parameterValue: string
    valueType?: $Enums.ValueType
    unit?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalculationParameterCreateOrConnectWithoutCalculationTypeInput = {
    where: CalculationParameterWhereUniqueInput
    create: XOR<CalculationParameterCreateWithoutCalculationTypeInput, CalculationParameterUncheckedCreateWithoutCalculationTypeInput>
  }

  export type CalculationParameterCreateManyCalculationTypeInputEnvelope = {
    data: CalculationParameterCreateManyCalculationTypeInput | CalculationParameterCreateManyCalculationTypeInput[]
    skipDuplicates?: boolean
  }

  export type CalculationParameterUpsertWithWhereUniqueWithoutCalculationTypeInput = {
    where: CalculationParameterWhereUniqueInput
    update: XOR<CalculationParameterUpdateWithoutCalculationTypeInput, CalculationParameterUncheckedUpdateWithoutCalculationTypeInput>
    create: XOR<CalculationParameterCreateWithoutCalculationTypeInput, CalculationParameterUncheckedCreateWithoutCalculationTypeInput>
  }

  export type CalculationParameterUpdateWithWhereUniqueWithoutCalculationTypeInput = {
    where: CalculationParameterWhereUniqueInput
    data: XOR<CalculationParameterUpdateWithoutCalculationTypeInput, CalculationParameterUncheckedUpdateWithoutCalculationTypeInput>
  }

  export type CalculationParameterUpdateManyWithWhereWithoutCalculationTypeInput = {
    where: CalculationParameterScalarWhereInput
    data: XOR<CalculationParameterUpdateManyMutationInput, CalculationParameterUncheckedUpdateManyWithoutCalculationTypeInput>
  }

  export type CalculationTypeCreateWithoutParametersInput = {
    slug: string
    name: string
    description?: string | null
    formula?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalculationTypeUncheckedCreateWithoutParametersInput = {
    id?: number
    slug: string
    name: string
    description?: string | null
    formula?: string | null
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalculationTypeCreateOrConnectWithoutParametersInput = {
    where: CalculationTypeWhereUniqueInput
    create: XOR<CalculationTypeCreateWithoutParametersInput, CalculationTypeUncheckedCreateWithoutParametersInput>
  }

  export type CantonCreateWithoutCalculationParamsInput = {
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationCreateNestedManyWithoutCantonInput
    contacts?: ContactCreateNestedManyWithoutCantonInput
    examples?: ExampleCreateNestedManyWithoutCantonInput
  }

  export type CantonUncheckedCreateWithoutCalculationParamsInput = {
    id?: number
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationUncheckedCreateNestedManyWithoutCantonInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCantonInput
    examples?: ExampleUncheckedCreateNestedManyWithoutCantonInput
  }

  export type CantonCreateOrConnectWithoutCalculationParamsInput = {
    where: CantonWhereUniqueInput
    create: XOR<CantonCreateWithoutCalculationParamsInput, CantonUncheckedCreateWithoutCalculationParamsInput>
  }

  export type CalculationTypeUpsertWithoutParametersInput = {
    update: XOR<CalculationTypeUpdateWithoutParametersInput, CalculationTypeUncheckedUpdateWithoutParametersInput>
    create: XOR<CalculationTypeCreateWithoutParametersInput, CalculationTypeUncheckedCreateWithoutParametersInput>
    where?: CalculationTypeWhereInput
  }

  export type CalculationTypeUpdateToOneWithWhereWithoutParametersInput = {
    where?: CalculationTypeWhereInput
    data: XOR<CalculationTypeUpdateWithoutParametersInput, CalculationTypeUncheckedUpdateWithoutParametersInput>
  }

  export type CalculationTypeUpdateWithoutParametersInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationTypeUncheckedUpdateWithoutParametersInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CantonUpsertWithoutCalculationParamsInput = {
    update: XOR<CantonUpdateWithoutCalculationParamsInput, CantonUncheckedUpdateWithoutCalculationParamsInput>
    create: XOR<CantonCreateWithoutCalculationParamsInput, CantonUncheckedCreateWithoutCalculationParamsInput>
    where?: CantonWhereInput
  }

  export type CantonUpdateToOneWithWhereWithoutCalculationParamsInput = {
    where?: CantonWhereInput
    data: XOR<CantonUpdateWithoutCalculationParamsInput, CantonUncheckedUpdateWithoutCalculationParamsInput>
  }

  export type CantonUpdateWithoutCalculationParamsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUpdateManyWithoutCantonNestedInput
    contacts?: ContactUpdateManyWithoutCantonNestedInput
    examples?: ExampleUpdateManyWithoutCantonNestedInput
  }

  export type CantonUncheckedUpdateWithoutCalculationParamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUncheckedUpdateManyWithoutCantonNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCantonNestedInput
    examples?: ExampleUncheckedUpdateManyWithoutCantonNestedInput
  }

  export type ExampleCreateWithoutCategoryInput = {
    title: string
    description: string
    content: string
    eventType?: string | null
    capacity?: number | null
    imageUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    canton?: CantonCreateNestedOneWithoutExamplesInput
  }

  export type ExampleUncheckedCreateWithoutCategoryInput = {
    id?: number
    cantonId?: number | null
    title: string
    description: string
    content: string
    eventType?: string | null
    capacity?: number | null
    imageUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleCreateOrConnectWithoutCategoryInput = {
    where: ExampleWhereUniqueInput
    create: XOR<ExampleCreateWithoutCategoryInput, ExampleUncheckedCreateWithoutCategoryInput>
  }

  export type ExampleCreateManyCategoryInputEnvelope = {
    data: ExampleCreateManyCategoryInput | ExampleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ExampleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ExampleWhereUniqueInput
    update: XOR<ExampleUpdateWithoutCategoryInput, ExampleUncheckedUpdateWithoutCategoryInput>
    create: XOR<ExampleCreateWithoutCategoryInput, ExampleUncheckedCreateWithoutCategoryInput>
  }

  export type ExampleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ExampleWhereUniqueInput
    data: XOR<ExampleUpdateWithoutCategoryInput, ExampleUncheckedUpdateWithoutCategoryInput>
  }

  export type ExampleUpdateManyWithWhereWithoutCategoryInput = {
    where: ExampleScalarWhereInput
    data: XOR<ExampleUpdateManyMutationInput, ExampleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ExampleCategoryCreateWithoutExamplesInput = {
    slug: string
    name: string
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleCategoryUncheckedCreateWithoutExamplesInput = {
    id?: number
    slug: string
    name: string
    icon?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleCategoryCreateOrConnectWithoutExamplesInput = {
    where: ExampleCategoryWhereUniqueInput
    create: XOR<ExampleCategoryCreateWithoutExamplesInput, ExampleCategoryUncheckedCreateWithoutExamplesInput>
  }

  export type CantonCreateWithoutExamplesInput = {
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationCreateNestedManyWithoutCantonInput
    contacts?: ContactCreateNestedManyWithoutCantonInput
    calculationParams?: CalculationParameterCreateNestedManyWithoutCantonInput
  }

  export type CantonUncheckedCreateWithoutExamplesInput = {
    id?: number
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationUncheckedCreateNestedManyWithoutCantonInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCantonInput
    calculationParams?: CalculationParameterUncheckedCreateNestedManyWithoutCantonInput
  }

  export type CantonCreateOrConnectWithoutExamplesInput = {
    where: CantonWhereUniqueInput
    create: XOR<CantonCreateWithoutExamplesInput, CantonUncheckedCreateWithoutExamplesInput>
  }

  export type ExampleCategoryUpsertWithoutExamplesInput = {
    update: XOR<ExampleCategoryUpdateWithoutExamplesInput, ExampleCategoryUncheckedUpdateWithoutExamplesInput>
    create: XOR<ExampleCategoryCreateWithoutExamplesInput, ExampleCategoryUncheckedCreateWithoutExamplesInput>
    where?: ExampleCategoryWhereInput
  }

  export type ExampleCategoryUpdateToOneWithWhereWithoutExamplesInput = {
    where?: ExampleCategoryWhereInput
    data: XOR<ExampleCategoryUpdateWithoutExamplesInput, ExampleCategoryUncheckedUpdateWithoutExamplesInput>
  }

  export type ExampleCategoryUpdateWithoutExamplesInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleCategoryUncheckedUpdateWithoutExamplesInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CantonUpsertWithoutExamplesInput = {
    update: XOR<CantonUpdateWithoutExamplesInput, CantonUncheckedUpdateWithoutExamplesInput>
    create: XOR<CantonCreateWithoutExamplesInput, CantonUncheckedCreateWithoutExamplesInput>
    where?: CantonWhereInput
  }

  export type CantonUpdateToOneWithWhereWithoutExamplesInput = {
    where?: CantonWhereInput
    data: XOR<CantonUpdateWithoutExamplesInput, CantonUncheckedUpdateWithoutExamplesInput>
  }

  export type CantonUpdateWithoutExamplesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUpdateManyWithoutCantonNestedInput
    contacts?: ContactUpdateManyWithoutCantonNestedInput
    calculationParams?: CalculationParameterUpdateManyWithoutCantonNestedInput
  }

  export type CantonUncheckedUpdateWithoutExamplesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUncheckedUpdateManyWithoutCantonNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCantonNestedInput
    calculationParams?: CalculationParameterUncheckedUpdateManyWithoutCantonNestedInput
  }

  export type ContactCreateWithoutContactTypeInput = {
    name: string
    department?: string | null
    street?: string | null
    postalCode?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    canton?: CantonCreateNestedOneWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutContactTypeInput = {
    id?: number
    cantonId?: number | null
    name: string
    department?: string | null
    street?: string | null
    postalCode?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateOrConnectWithoutContactTypeInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutContactTypeInput, ContactUncheckedCreateWithoutContactTypeInput>
  }

  export type ContactCreateManyContactTypeInputEnvelope = {
    data: ContactCreateManyContactTypeInput | ContactCreateManyContactTypeInput[]
    skipDuplicates?: boolean
  }

  export type ContactUpsertWithWhereUniqueWithoutContactTypeInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutContactTypeInput, ContactUncheckedUpdateWithoutContactTypeInput>
    create: XOR<ContactCreateWithoutContactTypeInput, ContactUncheckedCreateWithoutContactTypeInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutContactTypeInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutContactTypeInput, ContactUncheckedUpdateWithoutContactTypeInput>
  }

  export type ContactUpdateManyWithWhereWithoutContactTypeInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutContactTypeInput>
  }

  export type CantonCreateWithoutContactsInput = {
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationCreateNestedManyWithoutCantonInput
    calculationParams?: CalculationParameterCreateNestedManyWithoutCantonInput
    examples?: ExampleCreateNestedManyWithoutCantonInput
  }

  export type CantonUncheckedCreateWithoutContactsInput = {
    id?: number
    code: string
    name: string
    nameOfficial: string
    coatOfArms?: string | null
    language?: $Enums.CantonLanguage
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    regulations?: RegulationUncheckedCreateNestedManyWithoutCantonInput
    calculationParams?: CalculationParameterUncheckedCreateNestedManyWithoutCantonInput
    examples?: ExampleUncheckedCreateNestedManyWithoutCantonInput
  }

  export type CantonCreateOrConnectWithoutContactsInput = {
    where: CantonWhereUniqueInput
    create: XOR<CantonCreateWithoutContactsInput, CantonUncheckedCreateWithoutContactsInput>
  }

  export type ContactTypeCreateWithoutContactsInput = {
    slug: string
    name: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTypeUncheckedCreateWithoutContactsInput = {
    id?: number
    slug: string
    name: string
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTypeCreateOrConnectWithoutContactsInput = {
    where: ContactTypeWhereUniqueInput
    create: XOR<ContactTypeCreateWithoutContactsInput, ContactTypeUncheckedCreateWithoutContactsInput>
  }

  export type CantonUpsertWithoutContactsInput = {
    update: XOR<CantonUpdateWithoutContactsInput, CantonUncheckedUpdateWithoutContactsInput>
    create: XOR<CantonCreateWithoutContactsInput, CantonUncheckedCreateWithoutContactsInput>
    where?: CantonWhereInput
  }

  export type CantonUpdateToOneWithWhereWithoutContactsInput = {
    where?: CantonWhereInput
    data: XOR<CantonUpdateWithoutContactsInput, CantonUncheckedUpdateWithoutContactsInput>
  }

  export type CantonUpdateWithoutContactsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUpdateManyWithoutCantonNestedInput
    calculationParams?: CalculationParameterUpdateManyWithoutCantonNestedInput
    examples?: ExampleUpdateManyWithoutCantonNestedInput
  }

  export type CantonUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameOfficial?: StringFieldUpdateOperationsInput | string
    coatOfArms?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumCantonLanguageFieldUpdateOperationsInput | $Enums.CantonLanguage
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: RegulationUncheckedUpdateManyWithoutCantonNestedInput
    calculationParams?: CalculationParameterUncheckedUpdateManyWithoutCantonNestedInput
    examples?: ExampleUncheckedUpdateManyWithoutCantonNestedInput
  }

  export type ContactTypeUpsertWithoutContactsInput = {
    update: XOR<ContactTypeUpdateWithoutContactsInput, ContactTypeUncheckedUpdateWithoutContactsInput>
    create: XOR<ContactTypeCreateWithoutContactsInput, ContactTypeUncheckedCreateWithoutContactsInput>
    where?: ContactTypeWhereInput
  }

  export type ContactTypeUpdateToOneWithWhereWithoutContactsInput = {
    where?: ContactTypeWhereInput
    data: XOR<ContactTypeUpdateWithoutContactsInput, ContactTypeUncheckedUpdateWithoutContactsInput>
  }

  export type ContactTypeUpdateWithoutContactsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTypeUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationCreateManyCantonInput = {
    id?: number
    categoryId: number
    title: string
    summary: string
    content: string
    legalReference?: string | null
    sourceUrl?: string | null
    effectiveDate?: Date | string | null
    isActive?: boolean
    version?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyCantonInput = {
    id?: number
    contactTypeId: number
    name: string
    department?: string | null
    street?: string | null
    postalCode?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalculationParameterCreateManyCantonInput = {
    id?: number
    calculationTypeId: number
    parameterKey: string
    parameterValue: string
    valueType?: $Enums.ValueType
    unit?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleCreateManyCantonInput = {
    id?: number
    categoryId: number
    title: string
    description: string
    content: string
    eventType?: string | null
    capacity?: number | null
    imageUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegulationUpdateWithoutCantonInput = {
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: RegulationCategoryUpdateOneRequiredWithoutRegulationsNestedInput
  }

  export type RegulationUncheckedUpdateWithoutCantonInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationUncheckedUpdateManyWithoutCantonInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutCantonInput = {
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactType?: ContactTypeUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutCantonInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactTypeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutCantonInput = {
    id?: IntFieldUpdateOperationsInput | number
    contactTypeId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationParameterUpdateWithoutCantonInput = {
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculationType?: CalculationTypeUpdateOneRequiredWithoutParametersNestedInput
  }

  export type CalculationParameterUncheckedUpdateWithoutCantonInput = {
    id?: IntFieldUpdateOperationsInput | number
    calculationTypeId?: IntFieldUpdateOperationsInput | number
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationParameterUncheckedUpdateManyWithoutCantonInput = {
    id?: IntFieldUpdateOperationsInput | number
    calculationTypeId?: IntFieldUpdateOperationsInput | number
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleUpdateWithoutCantonInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: ExampleCategoryUpdateOneRequiredWithoutExamplesNestedInput
  }

  export type ExampleUncheckedUpdateWithoutCantonInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleUncheckedUpdateManyWithoutCantonInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationCreateManyCategoryInput = {
    id?: number
    cantonId: number
    title: string
    summary: string
    content: string
    legalReference?: string | null
    sourceUrl?: string | null
    effectiveDate?: Date | string | null
    isActive?: boolean
    version?: number
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegulationUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canton?: CantonUpdateOneRequiredWithoutRegulationsNestedInput
  }

  export type RegulationUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegulationUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    legalReference?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    version?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationParameterCreateManyCalculationTypeInput = {
    id?: number
    cantonId?: number | null
    parameterKey: string
    parameterValue: string
    valueType?: $Enums.ValueType
    unit?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalculationParameterUpdateWithoutCalculationTypeInput = {
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canton?: CantonUpdateOneWithoutCalculationParamsNestedInput
  }

  export type CalculationParameterUncheckedUpdateWithoutCalculationTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalculationParameterUncheckedUpdateManyWithoutCalculationTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    parameterKey?: StringFieldUpdateOperationsInput | string
    parameterValue?: StringFieldUpdateOperationsInput | string
    valueType?: EnumValueTypeFieldUpdateOperationsInput | $Enums.ValueType
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleCreateManyCategoryInput = {
    id?: number
    cantonId?: number | null
    title: string
    description: string
    content: string
    eventType?: string | null
    capacity?: number | null
    imageUrl?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExampleUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canton?: CantonUpdateOneWithoutExamplesNestedInput
  }

  export type ExampleUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExampleUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateManyContactTypeInput = {
    id?: number
    cantonId?: number | null
    name: string
    department?: string | null
    street?: string | null
    postalCode?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateWithoutContactTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canton?: CantonUpdateOneWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutContactTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyWithoutContactTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cantonId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}